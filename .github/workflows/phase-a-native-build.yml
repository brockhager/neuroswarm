name: NS-LLM Native Build

on:
  workflow_dispatch:
  push:
    paths:
      - 'NS-LLM/**'
    tags:
      - 'v*.*.*'

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4

      - name: Debug Directory Structure (Recursive)
        run: |
          echo "Workspace: ${{ github.workspace }}"
          ls -R ${{ github.workspace }}

      - name: Read repo VERSION (version-id.txt) — Linux / macOS
        if: runner.os != 'Windows'
        run: |
          if [ -f "version-id.txt" ]; then
            VERSION=$(cat version-id.txt | tr -d '\n' | tr -d '\r')
          else
            VERSION=dev
          fi
          echo "Read VERSION=$VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Read repo VERSION (version-id.txt) — Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      - name: Read repo VERSION (version-id.txt) — Linux / macOS
        if: runner.os != 'Windows'
        run: |
          if [ -f "version-id.txt" ]; then
            VERSION=$(cat version-id.txt | tr -d '\n' | tr -d '\r')
          else
            VERSION=dev
          fi
          echo "Read VERSION=$VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Read repo VERSION (version-id.txt) — Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1


      - name: Install ONNX Runtime (best-effort)
        run: |
          echo "VERSION=${VERSION} — Attempting to install ONNX Runtime for ${RUNNER_OS} (this step is best-effort; configure ONNXRUNTIME_DIR if required)"
          if [ "${RUNNER_OS}" = "Linux" ]; then
            python -m pip install --upgrade pip
            pip install onnxruntime
          fi
        shell: bash

      - name: Prepare native build directory
        shell: bash
        run: |
          echo "Looking for NS-LLM/native in $(pwd)"
          ls -F
          if [ ! -d "NS-LLM/native" ]; then
            echo "NS-LLM/native not found!"
            ls -R
            exit 1
          fi
          cd NS-LLM/native
          mkdir -p build
          cd build
          echo "build directory ready"

      # (ONNX prepare steps run next on tag pushes — we will configure + build afterwards)

      - name: "Ubuntu: Prepare ONNX runtime + quantized model for native inference"
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -e
          echo "Downloading ONNX Runtime package (prebuilt)"
          ORT_VER="${ONNXRUNTIME_VERSION:-1.15.1}"
          URL="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-linux-x64-${ORT_VER}.tgz"
          mkdir -p /tmp/onnxruntime
          echo "Downloading $URL"
          curl -sL "$URL" -o /tmp/onnxruntime/onnx.tgz || (echo 'Failed to download ORT cli tarball' && exit 0)
          if [ -f /tmp/onnxruntime/onnx.tgz ]; then
            tar -xzf /tmp/onnxruntime/onnx.tgz -C /tmp/onnxruntime || true
            # Set a portable ONNXRUNTIME_DIR under project for CMake
            export ONNXRUNTIME_DIR=${{ github.workspace }}/NS-LLM/native/onnxruntime
            mkdir -p "$ONNXRUNTIME_DIR"
            cp -r /tmp/onnxruntime/* "$ONNXRUNTIME_DIR/" || true
            echo "Exported ONNXRUNTIME_DIR=$ONNXRUNTIME_DIR"
          else
            echo "ONNX runtime tarball missing - will attempt to build prototype only"
          fi

          echo "Installing python deps for model export (may take time)"
          python -m pip install --upgrade pip
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt

          echo "Running model pipeline export (all-MiniLM-L6-v2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force

          echo "Re-configure native build to link with ONNX runtime (PROTOTYPE_ONLY=OFF) — VERSION=${VERSION}"
          cd ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR"
          cmake --build . --config Release

      - name: "macOS: Prepare ONNX runtime + quantized model for native inference"
        if: matrix.os == 'macos-latest' && startsWith(github.ref, 'refs/tags/')
        run: |
          set -e
          ORT_VER="${ONNXRUNTIME_VERSION:-1.15.1}"
          # Try x64 then arm64 packages
          URL_X64="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-osx-x64-${ORT_VER}.tgz"
          URL_ARM="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-osx-arm64-${ORT_VER}.tgz"
          mkdir -p /tmp/onnxruntime
          echo "Trying $URL_X64"
          curl -sL "$URL_X64" -o /tmp/onnxruntime/onnx.tgz || true
          if [ ! -f /tmp/onnxruntime/onnx.tgz ]; then
            echo "Trying $URL_ARM"
            curl -sL "$URL_ARM" -o /tmp/onnxruntime/onnx.tgz || true
          fi
          if [ -f /tmp/onnxruntime/onnx.tgz ]; then
            tar -xzf /tmp/onnxruntime/onnx.tgz -C /tmp/onnxruntime || true
            export ONNXRUNTIME_DIR=${{ github.workspace }}/NS-LLM/native/onnxruntime
            mkdir -p "$ONNXRUNTIME_DIR"
            cp -r /tmp/onnxruntime/* "$ONNXRUNTIME_DIR/" || true
            echo "ONNXRUNTIME_DIR=$ONNXRUNTIME_DIR"
          else
            echo "No macOS ONNX runtime package found; will attempt prototype-only build"
          fi

          python -m pip install --upgrade pip
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt || true

          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force || true

          cd ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR" || true
          cmake --build . --config Release || true

      - name: "macOS: Run native inference smoke tests (if built)"
        if: matrix.os == 'macos-latest' && startsWith(github.ref, 'refs/tags/')
        run: |
          set -e
          cd NS-LLM
          node test-native-inference.js || echo 'native inference tests failed (or missing)'

      - name: "Ubuntu: Run native inference smoke tests (if built)"
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -e
          cd NS-LLM
          node test-native-inference.js || echo 'native inference tests failed (or missing)'

      - name: Compute checksums and manifest (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          set -e
          ARTDIR=${{ github.workspace }}/NS-LLM/native/build
          OUTDIR=${{ runner.temp }}/ns-llm-artifacts
          mkdir -p "$OUTDIR"
          echo "Computing checksums in $ARTDIR"
          if [ -d "$ARTDIR" ]; then
            (cd "$ARTDIR" && find . -type f -print0 | xargs -0 sha256sum) > "$OUTDIR/checksums.txt" || true
            # Build manifest.json with size & path & sha
            echo '{"files": [' > "$OUTDIR/manifest.json"
            first=1
            while IFS= read -r line; do
              sha=$(echo "$line" | awk '{print $1}')
              path=$(echo "$line" | awk '{$1=""; print substr($0,2)}')
              size=$(stat -c%s "$ARTDIR/$path" 2>/dev/null || stat -f%z "$ARTDIR/$path" 2>/dev/null || echo 0)
              if [ "$first" -eq 1 ]; then first=0; else echo "," >> "$OUTDIR/manifest.json"; fi
              printf '{"path":"%s","sha256":"%s","size":%s}' "$path" "$sha" "$size" >> "$OUTDIR/manifest.json"
            done < "$OUTDIR/checksums.txt"
            echo ']}' >> "$OUTDIR/manifest.json"
          else
            echo 'No artifacts folder to checksum; leaving manifest empty' > "$OUTDIR/manifest.json"
          fi

      - name: Compute checksums and manifest (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $artdir = Join-Path "${{ github.workspace }}" 'NS-LLM\native\build'
          $outdir = Join-Path $env:RUNNER_TEMP 'ns-llm-artifacts'
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          if (Test-Path $artdir) {
            Get-ChildItem -Path $artdir -Recurse -File | ForEach-Object { $h = Get-FileHash -Algorithm SHA256 -Path $_.FullName; $rel = $_.FullName.Substring($artdir.Length+1).Replace('\\','/'); "$($h.Hash)  $rel" } | Out-File -FilePath (Join-Path $outdir 'checksums.txt') -Encoding utf8
            $files = Get-ChildItem -Path $artdir -Recurse -File | ForEach-Object { $rel = $_.FullName.Substring($artdir.Length+1).Replace('\\','/'); [PSCustomObject]@{path=$rel; sha256=(Get-FileHash -Algorithm SHA256 -Path $_.FullName).Hash; size=(Get-Item $_.FullName).Length } }
            $manifest = @{ files = $files }
            $manifest | ConvertTo-Json -Depth 4 | Out-File -FilePath (Join-Path $outdir 'manifest.json') -Encoding utf8
          } else {
            '{"files": []}' | Out-File -FilePath (Join-Path $outdir 'manifest.json') -Encoding utf8
          }

      - name: Sign checksums (optional)
        continue-on-error: true
        run: |
          set -e
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "No GPG_PRIVATE_KEY present in secrets — skipping signing"
            exit 0
          fi
          mkdir -p $RUNNER_TEMP/gnupg
          export GNUPGHOME=$RUNNER_TEMP/gnupg
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          # sign the checksums produced earlier
          ARTDIR=$RUNNER_TEMP/ns-llm-artifacts
          if [ -f "$ARTDIR/checksums.txt" ]; then
            gpg --batch --yes --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" -o "$ARTDIR/checksums.txt.sig" --detach-sign "$ARTDIR/checksums.txt"
          else
            echo 'No checksums.txt present to sign.'
          fi

      - name: Upload native artifacts and metadata
        uses: actions/upload-artifact@v4
        with:
          name: ns-llm-native-${{ matrix.os }}-v${{ env.VERSION }}
          path: |
            NS-LLM/native/build
            ${{ runner.temp }}/ns-llm-artifacts/checksums.txt
            ${{ runner.temp }}/ns-llm-artifacts/manifest.json
            ${{ runner.temp }}/ns-llm-artifacts/checksums.txt.sig

      - name: "Windows: Prepare ONNX runtime + quantized model for native inference"
        if: matrix.os == 'windows-latest' && startsWith(github.ref, 'refs/tags/')
        shell: pwsh
        run: |
          $ORT_VER = $env:ONNXRUNTIME_VERSION -or '1.15.1'
          $url = "https://github.com/microsoft/onnxruntime/releases/download/v$ORT_VER/onnxruntime-win-x64-$ORT_VER.zip"
          $out = Join-Path $env:TEMP 'onnxruntime.zip'
          Write-Host "Downloading $url"
          Invoke-WebRequest -Uri $url -OutFile $out -UseBasicParsing -ErrorAction SilentlyContinue
          if (Test-Path $out) {
            Expand-Archive -Path $out -DestinationPath (Join-Path "${{ github.workspace }}" 'NS-LLM\native\onnxruntime') -Force
            $env:ONNXRUNTIME_DIR = Join-Path "${{ github.workspace }}" 'NS-LLM\native\onnxruntime'
            Write-Host "ONNXRUNTIME_DIR=$env:ONNXRUNTIME_DIR"
          } else {
            Write-Host 'ONNX Runtime zip not found — will try prototype-only build'
          }

          python -m pip install --upgrade pip
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt -ErrorAction SilentlyContinue
          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force -ErrorAction SilentlyContinue

          # Reconfigure CMake with ONNXRUNTIME_DIR for Windows
          Push-Location ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$env:ONNXRUNTIME_DIR" || Write-Host 'cmake configure failed'
          cmake --build . --config Release || Write-Host 'cmake build failed'
          Pop-Location

      - name: "Windows: Run native inference smoke tests (if built)"
        if: matrix.os == 'windows-latest' && startsWith(github.ref, 'refs/tags/')
        shell: pwsh
        run: |
          Set-Location NS-LLM
          node test-native-inference.js || Write-Host 'native inference tests failed (or missing)'

      - name: Configure + Build native binary (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          set -e
          cd NS-LLM/native/build
          set -e
          # If ONNXRUNTIME_DIR is present OR this is a tag push, build with ONNX support.
          if [ -n "$ONNXRUNTIME_DIR" ] || [[ "$GITHUB_REF" == refs/tags/* ]]; then
            echo "Configuring with ONNX support"
            cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR"
          else
            echo "Configuring prototype-only build"
            cmake .. -DPROTOTYPE_ONLY=ON
          fi
          cmake --build . --config Release

      - name: Configure + Build native binary (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Push-Location ${{ github.workspace }}/NS-LLM/native/build
          if ($env:ONNXRUNTIME_DIR -or $env:GITHUB_REF -like 'refs/tags/*') {
            Write-Host 'Configuring with ONNX support'
            cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$env:ONNXRUNTIME_DIR"
          } else {
            Write-Host 'Configuring prototype-only build'
            cmake .. -DPROTOTYPE_ONLY=ON
          }
          cmake --build . --config Release
          Pop-Location

      - name: Run native unit smoke tests (if built)
        run: |
          set -e
          node test-native-inference.js || echo 'native inference tests failed (or missing)'

  integration:
    name: Integration tests (NS-LLM prototype + NS Node) — ${{ matrix.runner-os }}
    runs-on: ${{ matrix.runner-os }}
    needs: build
    strategy:
      matrix:
        runner-os: [ubuntu-latest, macos-latest, windows-latest]
    env:
      STRICT_EMBED_DIM: '1'
      CHECK_EMBED_RANGE: '1'
      STRICT_EMBED_RANGE: '1'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install NS-LLM prototype deps
        working-directory: NS-LLM
        run: npm ci

      - name: Install NS Node deps
        working-directory: ns-node
        run: npm ci

      - name: Try to download native binary artifact (for this runner)
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-${{ matrix.runner-os }}-v${{ env.VERSION }}
          path: NS-LLM/native/artifact
        continue-on-error: true

      - name: Start NS-LLM backend (Linux/macOS - prefer native artifact)
        if: matrix.runner-os != 'windows-latest'
        working-directory: NS-LLM
        run: |
          # Find any candidate native binary inside the downloaded artifact
          BIN=$(find NS-LLM/native/artifact -type f -iname 'ns-llm-native*' -print -quit || true)
          if [ -n "$BIN" ]; then
            echo "Found native binary: $BIN — starting with --stub"
            chmod +x "$BIN" || true
            nohup "$BIN" --stub > ns-llm-native.log 2>&1 &
          else
            echo "Native artifact not found — starting Node.js prototype"
            nohup node index.js > ns-llm.log 2>&1 &
          fi

      - name: Start NS Node (Linux/macOS)
        if: matrix.runner-os != 'windows-latest'
        working-directory: ns-node
        run: |
          nohup node server.js > ns-node.log 2>&1 &

      - name: Start NS Node (Windows)
        if: matrix.runner-os == 'windows-latest'
        working-directory: ns-node
        shell: pwsh
        run: |
          Start-Process -FilePath node -ArgumentList 'server.js' -NoNewWindow

      - name: Wait for services to be healthy (Linux/macOS)
        if: matrix.runner-os != 'windows-latest'
        run: |
          set -e
          for i in {1..30}; do
            echo "Checking ns-llm at http://127.0.0.1:5555/health... ($i)"
            if curl --silent --fail http://127.0.0.1:5555/health >/dev/null 2>&1; then
              echo "ns-llm is up"; break
            fi
            sleep 1
          done
          for i in {1..30}; do
            echo "Checking ns-node at http://127.0.0.1:3009/health... ($i)"
            if curl --silent --fail http://127.0.0.1:3009/health >/dev/null 2>&1; then
              echo "ns-node is up"; break
            fi
            sleep 1
          done

      - name: Wait for services to be healthy (Windows)
        if: matrix.runner-os == 'windows-latest'
        shell: pwsh
        run: |
          $ready = $false
          for ($i=1; $i -le 60; $i++) {
            try {
              $r = Invoke-WebRequest -Uri 'http://127.0.0.1:5555/health' -UseBasicParsing -TimeoutSec 2
              if ($r.StatusCode -eq 200) { Write-Host 'ns-llm is up'; $ready = $true; break }
            } catch { Start-Sleep -Seconds 1 }
          }
          if (-not $ready) { Write-Error 'ns-llm did not become healthy' ; exit 1 }

          $ready = $false
          for ($i=1; $i -le 60; $i++) {
            try {
              $r = Invoke-WebRequest -Uri 'http://127.0.0.1:3009/health' -UseBasicParsing -TimeoutSec 2
              if ($r.StatusCode -eq 200) { Write-Host 'ns-node is up'; $ready = $true; break }
            } catch { Start-Sleep -Seconds 1 }
          }
          if (-not $ready) { Write-Error 'ns-node did not become healthy' ; exit 1 }

      - name: Run smoke + e2e tests (prototype/native)
        working-directory: ns-node
        run: |
          set -e
          npm run test:smoke:ns-llm
          npm run test:e2e:embed

      - name: Run strict embed test (native path validation)
        working-directory: ns-node
        run: |
          set -e
          echo "Running strict embed check (STRICT_EMBED_DIM=1)"
          STRICT_EMBED_DIM=1 npm run test:e2e:embed

  publish_release:
    name: Publish release artifacts (optional)
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/') }}
    steps:
      - uses: actions/checkout@v4

      - name: Read repo VERSION (version-id.txt) — Linux / macOS
        if: runner.os != 'Windows'
        run: |
          if [ -f "version-id.txt" ]; then
            VERSION=$(cat version-id.txt | tr -d '\n' | tr -d '\r')
          else
            VERSION=dev
          fi
          echo "Read VERSION=$VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Read repo VERSION (version-id.txt) — Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-ubuntu-latest-v${{ env.VERSION }}
          path: release-artifacts/ubuntu || true

      - name: Download macOS artifact
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-macos-latest-v${{ env.VERSION }}
          path: release-artifacts/macos || true

      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-windows-latest-v${{ env.VERSION }}
          path: release-artifacts/windows || true

      - name: Create GitHub Release
        id: create_release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          name: "NS-LLM Phase A artifacts - ${{ github.ref_name }}"
          body: "Production-ready NS-LLM artifacts validated across Ubuntu/macOS/Windows. See attached artifacts."

      - name: Upload release assets (ubuntu)
        if: always()
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release-artifacts/ubuntu/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets (macos)
        if: always()
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release-artifacts/macos/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets (windows)
        if: always()
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release-artifacts/windows/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
