name: NS-LLM Native Build

on:
  workflow_dispatch:
  push:
    paths:
      - 'NS-LLM/**'
    tags:
      - 'v*.*.*'

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4

      - name: Debug Directory Structure (Recursive)
        run: |
          echo "Workspace: ${{ github.workspace }}"
          ls -R ${{ github.workspace }}

      - name: Read repo VERSION (version-id.txt) — Linux / macOS
        if: runner.os != 'Windows'
        run: |
          if [ -f "version-id.txt" ]; then
            VERSION=$(cat version-id.txt | tr -d '\n' | tr -d '\r')
          else
            VERSION=dev
          fi
          echo "Read VERSION=$VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Read repo VERSION (version-id.txt) — Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      - name: Read repo VERSION (version-id.txt) — Linux / macOS
        if: runner.os != 'Windows'
        run: |
          if [ -f "version-id.txt" ]; then
            VERSION=$(cat version-id.txt | tr -d '\n' | tr -d '\r')
          else
            VERSION=dev
          fi
          echo "Read VERSION=$VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Read repo VERSION (version-id.txt) — Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1


      - name: Install ONNX Runtime (best-effort)
        run: |
          echo "VERSION=${VERSION} — Attempting to install ONNX Runtime for ${RUNNER_OS} (this step is best-effort; configure ONNXRUNTIME_DIR if required)"
          if [ "${RUNNER_OS}" = "Linux" ]; then
            python -m pip install --upgrade pip
            pip install onnxruntime
          fi
        shell: bash

      - name: Prepare native build directory
        shell: bash
        run: |
          echo "Looking for NS-LLM/native in $(pwd)"
          ls -F
          if [ ! -d "NS-LLM/native" ]; then
            echo "NS-LLM/native not found!"
            ls -R
            exit 1
          fi
          cd NS-LLM/native
          mkdir -p build
          cd build
          echo "build directory ready"

      # (ONNX prepare steps run next on tag pushes — we will configure + build afterwards)

      - name: "Ubuntu: Prepare ONNX runtime + quantized model for native inference"
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -e
          echo "Downloading ONNX Runtime package (prebuilt)"
          ORT_VER="${ONNXRUNTIME_VERSION:-1.15.1}"
          URL="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-linux-x64-${ORT_VER}.tgz"
          mkdir -p /tmp/onnxruntime
          echo "Downloading $URL"
          curl -sL "$URL" -o /tmp/onnxruntime/onnx.tgz || (echo 'Failed to download ORT cli tarball' && exit 0)
          if [ -f /tmp/onnxruntime/onnx.tgz ]; then
            tar -xzf /tmp/onnxruntime/onnx.tgz -C /tmp/onnxruntime || true
            # Set a portable ONNXRUNTIME_DIR under project for CMake
            export ONNXRUNTIME_DIR=${{ github.workspace }}/NS-LLM/native/onnxruntime
            mkdir -p "$ONNXRUNTIME_DIR"
            cp -r /tmp/onnxruntime/* "$ONNXRUNTIME_DIR/" || true
            echo "Exported ONNXRUNTIME_DIR=$ONNXRUNTIME_DIR"
          else
            echo "ONNX runtime tarball missing - will attempt to build prototype only"
          fi

          echo "Installing python deps for model export (may take time)"
          python -m pip install --upgrade pip
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt

          echo "Running model pipeline export (all-MiniLM-L6-v2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force

          echo "Running generative model export (gpt2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/export_generative.py --model gpt2 --out ${{ github.workspace }}/NS-LLM/models/gpt2.onnx --quantize

          # Copy models to build directory for tests
          mkdir -p ${{ github.workspace }}/NS-LLM/native/build/models
          cp -r ${{ github.workspace }}/NS-LLM/models/* ${{ github.workspace }}/NS-LLM/native/build/models/

          echo "Re-configure native build to link with ONNX runtime (PROTOTYPE_ONLY=OFF) — VERSION=${VERSION}"
          cd ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR"
          cmake --build . --config Release

      - name: "macOS: Prepare ONNX runtime + quantized model for native inference"
        if: matrix.os == 'macos-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        run: |
          set -e
          ORT_VER="${ONNXRUNTIME_VERSION:-1.15.1}"
          # Try x64 then arm64 packages
          URL_X64="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-osx-x64-${ORT_VER}.tgz"
          URL_ARM="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-osx-arm64-${ORT_VER}.tgz"
          mkdir -p /tmp/onnxruntime
          echo "Trying $URL_X64"
          curl -sL "$URL_X64" -o /tmp/onnxruntime/onnx.tgz || true
          if [ ! -f /tmp/onnxruntime/onnx.tgz ]; then
            echo "Trying $URL_ARM"
            curl -sL "$URL_ARM" -o /tmp/onnxruntime/onnx.tgz || true
          fi
          if [ -f /tmp/onnxruntime/onnx.tgz ]; then
            tar -xzf /tmp/onnxruntime/onnx.tgz -C /tmp/onnxruntime || true
            export ONNXRUNTIME_DIR=${{ github.workspace }}/NS-LLM/native/onnxruntime
            mkdir -p "$ONNXRUNTIME_DIR"
            cp -r /tmp/onnxruntime/* "$ONNXRUNTIME_DIR/" || true
            echo "ONNXRUNTIME_DIR=$ONNXRUNTIME_DIR"
          else
            echo "No macOS ONNX runtime package found; will attempt prototype-only build"
          fi

          python -m pip install --upgrade pip
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt || true

          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force || true

          echo "Running generative model export (gpt2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/export_generative.py --model gpt2 --out ${{ github.workspace }}/NS-LLM/models/gpt2.onnx --quantize || true

          # Copy models to build directory for tests
          mkdir -p ${{ github.workspace }}/NS-LLM/native/build/models
          cp -r ${{ github.workspace }}/NS-LLM/models/* ${{ github.workspace }}/NS-LLM/native/build/models/ || true

          cd ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR" || true
          cmake --build . --config Release || true

      - name: "macOS: Run native inference smoke tests (if built)"
        if: matrix.os == 'macos-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        run: |
          set -e
          cd NS-LLM
          node test-native-inference.js || echo 'native inference tests failed (or missing)'

      - name: "macOS: Run native generative smoke tests (real)"
        if: matrix.os == 'macos-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        run: |
          set -e
          cd NS-LLM/native/build
          # Run with real inference (no --stub)
          echo '{"cmd":"generate", "text":"The quick brown fox"}' | ./ns-llm-native | grep "tokens_generated"

          node test-native-inference.js || echo 'native inference tests failed (or missing)'

      - name: "Ubuntu: Run native generative smoke tests (real)"
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -e
          cd NS-LLM/native/build
          # Run with real inference (no --stub)
          echo '{"cmd":"generate", "text":"The quick brown fox"}' | ./ns-llm-native | grep "tokens_generated"

      - name: Compute checksums and manifest (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          set -e
          ARTDIR=${{ github.workspace }}/NS-LLM/native/build
          OUTDIR=${{ runner.temp }}/ns-llm-artifacts
          mkdir -p "$OUTDIR"
          echo "Computing checksums in $ARTDIR"
          if [ -d "$ARTDIR" ]; then
            (cd "$ARTDIR" && find . -type f -print0 | xargs -0 sha256sum) > "$OUTDIR/checksums.txt" || true
            # Build manifest.json with size & path & sha
            echo '{"files": [' > "$OUTDIR/manifest.json"
            first=1
            while IFS= read -r line; do
              sha=$(echo "$line" | awk '{print $1}')
              path=$(echo "$line" | awk '{$1=""; print substr($0,2)}')
              size=$(stat -c%s "$ARTDIR/$path" 2>/dev/null || stat -f%z "$ARTDIR/$path" 2>/dev/null || echo 0)
              if [ "$first" -eq 1 ]; then first=0; else echo "," >> "$OUTDIR/manifest.json"; fi
              printf '{"path":"%s","sha256":"%s","size":%s}' "$path" "$sha" "$size" >> "$OUTDIR/manifest.json"
            done < "$OUTDIR/checksums.txt"
            echo ']}' >> "$OUTDIR/manifest.json"
          else
            echo 'No artifacts folder to checksum; leaving manifest empty' > "$OUTDIR/manifest.json"
          fi

      - name: Compute checksums and manifest (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $artdir = Join-Path "${{ github.workspace }}" 'NS-LLM\native\build'
          $outdir = Join-Path $env:RUNNER_TEMP 'ns-llm-artifacts'
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          if (Test-Path $artdir) {
            Get-ChildItem -Path $artdir -Recurse -File | ForEach-Object { $h = Get-FileHash -Algorithm SHA256 -Path $_.FullName; $rel = $_.FullName.Substring($artdir.Length+1).Replace('\\','/'); "$($h.Hash)  $rel" } | Out-File -FilePath (Join-Path $outdir 'checksums.txt') -Encoding utf8
            $files = Get-ChildItem -Path $artdir -Recurse -File | ForEach-Object { $rel = $_.FullName.Substring($artdir.Length+1).Replace('\\','/'); [PSCustomObject]@{path=$rel; sha256=(Get-FileHash -Algorithm SHA256 -Path $_.FullName).Hash; size=(Get-Item $_.FullName).Length } }
            $manifest = @{ files = $files }
            $manifest | ConvertTo-Json -Depth 4 | Out-File -FilePath (Join-Path $outdir 'manifest.json') -Encoding utf8
          } else {
            '{"files": []}' | Out-File -FilePath (Join-Path $outdir 'manifest.json') -Encoding utf8
          }

      - name: Sign checksums (optional)
        continue-on-error: true
        run: |
          set -e
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "No GPG_PRIVATE_KEY present in secrets — skipping signing"
            exit 0
          fi
          mkdir -p $RUNNER_TEMP/gnupg
          export GNUPGHOME=$RUNNER_TEMP/gnupg
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          # sign the checksums produced earlier
          ARTDIR=$RUNNER_TEMP/ns-llm-artifacts
          if [ -f "$ARTDIR/checksums.txt" ]; then
            gpg --batch --yes --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" -o "$ARTDIR/checksums.txt.sig" --detach-sign "$ARTDIR/checksums.txt"
          else
            echo 'No checksums.txt present to sign.'
          fi

      - name: Upload native artifacts and metadata
        uses: actions/upload-artifact@v4
        with:
          name: ns-llm-native-${{ matrix.os }}-v${{ env.VERSION }}
          path: |
            NS-LLM/native/build
            ${{ runner.temp }}/ns-llm-artifacts/checksums.txt
            ${{ runner.temp }}/ns-llm-artifacts/manifest.json
            ${{ runner.temp }}/ns-llm-artifacts/checksums.txt.sig

      - name: "Windows: Prepare ONNX runtime + quantized model for native inference"
        id: set_ort_version
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          # 1) Initialize with a safe default
          $ORT_VER = '1.15.1'

          # 2) Read the environment variable safely
          $EnvVar = $env:ONNXRUNTIME_VERSION

          # 3) Only overwrite if the env var is non-empty and not the problematic string 'True'
          if (-not [string]::IsNullOrEmpty($EnvVar) -and $EnvVar -ne 'True') {
              $ORT_VER = $EnvVar
          }

          Write-Host "Resolved ONNXRUNTIME_VERSION: $ORT_VER"

          # Write outputs the recommended way for GitHub Actions
          "ort_version=$ORT_VER" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          $DownloadBaseName = "v${ORT_VER}"
          "download_prefix=$DownloadBaseName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: "Windows: Validate ONNX Runtime Download URL"
        id: validate_ort_url
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        env:
          ORT_VER: ${{ steps.set_ort_version.outputs.ort_version }}
          DOWNLOAD_PREFIX: ${{ steps.set_ort_version.outputs.download_prefix }}
        run: |
          # Build candidate URLs and test primary -> fallback
          $BaseUrl = 'https://github.com/microsoft/onnxruntime/releases/download/'
          $DownloadPrefix = $env:DOWNLOAD_PREFIX

          # Normalize version for creating filenames (strip leading 'v' if present)
          if ($DownloadPrefix.StartsWith('v')) { $TestVersion = $DownloadPrefix.Substring(1) } else { $TestVersion = $DownloadPrefix }

          $PrimarySuffix = "onnxruntime-win-x64-${TestVersion}.zip"
          $FallbackSuffix = "onnxruntime-win-x64-${TestVersion}.tgz"

          $PrimaryUrl = "$BaseUrl$DownloadPrefix/$PrimarySuffix"
          $FallbackUrl = "$BaseUrl$DownloadPrefix/$FallbackSuffix"

          Write-Host "Attempting primary URL: $PrimaryUrl"

          function Test-UrlExistence {
            param([Parameter(Mandatory=$true)][string]$Url)
            try {
              $response = Invoke-WebRequest -Uri $Url -Method Head -MaximumRedirection 5 -UseBasicParsing -ErrorAction Stop
              if ($response.StatusCode -ge 200 -and $response.StatusCode -lt 400) {
                Write-Host "✅ Success — URL responded with $($response.StatusCode). Package found at: $Url"
                return $true
              } else {
                Write-Host "URL responded with unacceptable status code: $($response.StatusCode)."
                return $false
              }
            } catch {
              Write-Host "URL check failed (likely 404/Connection Error). Error: $($_.Exception.Message)"
              return $false
            }
          }

          $chosen = $null
          if (Test-UrlExistence -Url $PrimaryUrl) {
            $chosen = $PrimaryUrl
            $chosenSuffix = $PrimarySuffix
          } elseif (Test-UrlExistence -Url $FallbackUrl) {
            Write-Host "Note: Primary URL not found; using fallback URL: $FallbackUrl"
            $chosen = $FallbackUrl
            $chosenSuffix = $FallbackSuffix
          } else {
            Write-Host "❌ FATAL ERROR: Neither the primary ($PrimarySuffix) nor the fallback ($FallbackSuffix) ONNX Runtime package was found at the expected release location."
            exit 1
          }

          # Export chosen info to GITHUB_OUTPUT for downstream steps
          "download_url=$chosen" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "download_suffix=$chosenSuffix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: "Windows: Download and extract ONNX Runtime (if URL validated)"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        env:
          ORT_VER: ${{ steps.set_ort_version.outputs.ort_version }}
          DOWNLOAD_PREFIX: ${{ steps.set_ort_version.outputs.download_prefix }}
          DOWNLOAD_URL: ${{ steps.validate_ort_url.outputs.download_url }}
          DOWNLOAD_SUFFIX: ${{ steps.validate_ort_url.outputs.download_suffix }}
        run: |
          $url = $env:DOWNLOAD_URL
          # Pick a temporary filename that matches the chosen suffix so extraction works correctly
          if ($env:DOWNLOAD_SUFFIX -and $env:DOWNLOAD_SUFFIX -match '\.tgz$') { $out = Join-Path $env:TEMP 'onnxruntime.tgz' } else { $out = Join-Path $env:TEMP 'onnxruntime.zip' }

          Write-Host "Downloading $url to $out"
          Invoke-WebRequest -Uri $url -OutFile $out -UseBasicParsing -ErrorAction SilentlyContinue
          if (Test-Path $out) {
            $dest = Join-Path "${{ github.workspace }}" 'NS-LLM\native\onnxruntime'
            New-Item -ItemType Directory -Path $dest -Force | Out-Null

            if ($env:DOWNLOAD_SUFFIX -and $env:DOWNLOAD_SUFFIX -match '\.zip$') {
              Expand-Archive -Path $out -DestinationPath $dest -Force
            } elseif ($env:DOWNLOAD_SUFFIX -and $env:DOWNLOAD_SUFFIX -match '\.(tgz|tar.gz)$') {
              # Extract .tgz to a temporary folder, then copy all contents into the target
              $tmp = Join-Path $env:TEMP ('onnxruntime_extract_' + [guid]::NewGuid().ToString())
              New-Item -ItemType Directory -Path $tmp -Force | Out-Null
              tar -xzf $out -C $tmp
              Get-ChildItem -Path $tmp | ForEach-Object { Copy-Item -Path $_.FullName -Destination $dest -Recurse -Force }
            } else {
              Write-Host "Unknown archive type, attempting zip extraction"
              Expand-Archive -Path $out -DestinationPath $dest -Force
            }
            $env:ONNXRUNTIME_DIR = Join-Path "${{ github.workspace }}" 'NS-LLM\native\onnxruntime'
            Write-Host "ONNXRUNTIME_DIR=$env:ONNXRUNTIME_DIR"
          } else {
            Write-Host 'ONNX Runtime zip not found — will try prototype-only build'
          }

          python -m pip install --upgrade pip
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt -ErrorAction SilentlyContinue
          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force -ErrorAction SilentlyContinue

          Write-Host "Running generative model export (gpt2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/export_generative.py --model gpt2 --out ${{ github.workspace }}/NS-LLM/models/gpt2.onnx --quantize -ErrorAction SilentlyContinue

          # Copy models to build directory for tests
          $modelsDest = Join-Path "${{ github.workspace }}" 'NS-LLM\native\build\Release\models'
          New-Item -ItemType Directory -Path $modelsDest -Force | Out-Null
          Copy-Item -Path "${{ github.workspace }}\NS-LLM\models\*" -Destination $modelsDest -Recurse -Force

          # Reconfigure CMake with ONNXRUNTIME_DIR for Windows
          Push-Location ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$env:ONNXRUNTIME_DIR" || Write-Host 'cmake configure failed'
          cmake --build . --config Release || Write-Host 'cmake build failed'
          Pop-Location

      - name: "Windows: Smoke Test Extracted ONNX Runtime"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          $LibraryPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "NS-LLM/native/onnxruntime/lib/onnxruntime.lib"
          Write-Host "Verifying existence of core library file: $LibraryPath"
          if (Test-Path $LibraryPath -PathType Leaf) {
              Write-Host "✅ Smoke Test Passed: onnxruntime.lib found! The package was successfully downloaded and extracted."
          } else {
              Write-Host "❌ FATAL ERROR: Smoke Test Failed. Expected library file not found at $LibraryPath."
              Write-Host "This indicates a failure in download, extraction, or an unexpected change in the ONNX Runtime package structure."
              exit 1
          }

      - name: "Windows: Run native inference smoke tests (if built)"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          Set-Location NS-LLM
          node test-native-inference.js || Write-Host 'native inference tests failed (or missing)'

      - name: "Windows: Run native generative smoke tests (real)"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          Set-Location NS-LLM/native/build/Release
          # Run with real inference (no --stub)
          echo '{"cmd":"generate", "text":"The quick brown fox"}' | .\ns-llm-native.exe | Select-String "tokens_generated"

      - name: Configure + Build native binary (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          set -e
          cd NS-LLM/native/build
          set -e
          # If ONNXRUNTIME_DIR is present OR this is a tag push, build with ONNX support.
          if [ -n "$ONNXRUNTIME_DIR" ] || [[ "$GITHUB_REF" == refs/tags/* ]]; then
            echo "Configuring with ONNX support"
            cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR"
          else
            echo "Configuring prototype-only build"
            cmake .. -DPROTOTYPE_ONLY=ON
          fi
          cmake --build . --config Release

      - name: Configure + Build native binary (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Push-Location ${{ github.workspace }}/NS-LLM/native/build
          if ($env:ONNXRUNTIME_DIR -or $env:GITHUB_REF -like 'refs/tags/*') {
            Write-Host 'Configuring with ONNX support'
            cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$env:ONNXRUNTIME_DIR"
          } else {
            Write-Host 'Configuring prototype-only build'
            cmake .. -DPROTOTYPE_ONLY=ON
          }
          cmake --build . --config Release
          Pop-Location

      - name: Run native unit smoke tests (if built)
        shell: bash
        run: |
          set -e
          node test-native-inference.js || echo 'native inference tests failed (or missing)'

  integration:
    name: Integration tests (NS-LLM prototype + NS Node) — ${{ matrix.runner-os }}
    runs-on: ${{ matrix.runner-os }}
    needs: build
    strategy:
      matrix:
        runner-os: [ubuntu-latest, macos-latest, windows-latest]
    env:
      STRICT_EMBED_DIM: '1'
      CHECK_EMBED_RANGE: '1'
      STRICT_EMBED_RANGE: '1'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install NS-LLM prototype deps
        working-directory: NS-LLM
        run: npm install

      - name: Install Shared deps
        working-directory: shared
        run: npm install

      - name: Install NS Node deps
        working-directory: ns-node
        run: npm ci

      - name: Try to download native binary artifact (for this runner)
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-${{ matrix.runner-os }}-v${{ env.VERSION }}
          path: NS-LLM/native/artifact
        continue-on-error: true

      - name: Start NS-LLM backend (Linux/macOS - prefer native artifact)
        if: matrix.runner-os != 'windows-latest'
        run: |
          # Find any candidate native binary inside the downloaded artifact
          BIN=$(find NS-LLM/native/artifact -type f -iname 'ns-llm-native*' -print -quit || true)
          if [ -n "$BIN" ]; then
            echo "Found native binary: $BIN — starting with --stub"
            chmod +x "$BIN" || true
            nohup "$BIN" --stub > NS-LLM/ns-llm-native.log 2>&1 &
          else
            echo "Native artifact not found — starting Node.js prototype"
            cd NS-LLM && nohup node index.js > ns-llm.log 2>&1 &
          fi

      - name: Start NS Node (Linux/macOS)
        if: matrix.runner-os != 'windows-latest'
        working-directory: ns-node
        run: |
          nohup node server.js > ns-node.log 2>&1 &

      - name: Start NS Node (Windows)
        if: matrix.runner-os == 'windows-latest'
        working-directory: ns-node
        shell: pwsh
        run: |
          Start-Process -FilePath node -ArgumentList 'server.js' -NoNewWindow

      - name: Wait for services to be healthy (Linux/macOS)
        if: matrix.runner-os != 'windows-latest'
        run: |
          set -e
          NS_LLM_UP=false
          for i in {1..30}; do
            echo "Checking ns-llm at http://127.0.0.1:5555/health... ($i)"
            if curl --silent --fail http://127.0.0.1:5555/health >/dev/null 2>&1; then
              echo "ns-llm is up"
              NS_LLM_UP=true
              break
            fi
            sleep 1
          done
          
          NS_NODE_UP=false
          for i in {1..30}; do
            echo "Checking ns-node at http://127.0.0.1:3009/health... ($i)"
            if curl --silent --fail http://127.0.0.1:3009/health >/dev/null 2>&1; then
              echo "ns-node is up"
              NS_NODE_UP=true
              break
            fi
            sleep 1
          done
          
          # Check if services started successfully
          if [ "$NS_LLM_UP" = false ]; then
            echo "ERROR: ns-llm failed to start. Logs:"
            cat NS-LLM/ns-llm.log 2>/dev/null || cat NS-LLM/ns-llm-native.log 2>/dev/null || echo "No logs found"
            exit 1
          fi
          
          if [ "$NS_NODE_UP" = false ]; then
            echo "ERROR: ns-node failed to start. Logs:"
            cat ns-node/ns-node.log 2>/dev/null || echo "No logs found"
            exit 1
          fi

      - name: Wait for services to be healthy (Windows)
        if: matrix.runner-os == 'windows-latest'
        shell: pwsh
        run: |
          $ready = $false
          for ($i=1; $i -le 60; $i++) {
            try {
              $r = Invoke-WebRequest -Uri 'http://127.0.0.1:5555/health' -UseBasicParsing -TimeoutSec 2
              if ($r.StatusCode -eq 200) { Write-Host 'ns-llm is up'; $ready = $true; break }
            } catch { Start-Sleep -Seconds 1 }
          }
          if (-not $ready) { Write-Error 'ns-llm did not become healthy' ; exit 1 }

          $ready = $false
          for ($i=1; $i -le 60; $i++) {
            try {
              $r = Invoke-WebRequest -Uri 'http://127.0.0.1:3009/health' -UseBasicParsing -TimeoutSec 2
              if ($r.StatusCode -eq 200) { Write-Host 'ns-node is up'; $ready = $true; break }
            } catch { Start-Sleep -Seconds 1 }
          }
          if (-not $ready) { Write-Error 'ns-node did not become healthy' ; exit 1 }

      - name: Run smoke + e2e tests (prototype/native)
        working-directory: ns-node
        run: |
          set -e
          npm run test:smoke:ns-llm
          npm run test:e2e:embed

      - name: Run strict embed test (native path validation)
        working-directory: ns-node
        run: |
          set -e
          echo "Running strict embed check (STRICT_EMBED_DIM=1)"
          STRICT_EMBED_DIM=1 npm run test:e2e:embed

  publish_release:
    name: Publish release artifacts (optional)
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/') }}
    steps:
      - uses: actions/checkout@v4

      - name: Read repo VERSION (version-id.txt) — Linux / macOS
        if: runner.os != 'Windows'
        run: |
          if [ -f "version-id.txt" ]; then
            VERSION=$(cat version-id.txt | tr -d '\n' | tr -d '\r')
          else
            VERSION=dev
          fi
          echo "Read VERSION=$VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Read repo VERSION (version-id.txt) — Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-ubuntu-latest-v${{ env.VERSION }}
          path: release-artifacts/ubuntu || true

      - name: Download macOS artifact
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-macos-latest-v${{ env.VERSION }}
          path: release-artifacts/macos || true

      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-windows-latest-v${{ env.VERSION }}
          path: release-artifacts/windows || true

      - name: Create GitHub Release
        id: create_release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          name: "NS-LLM Phase A artifacts - ${{ github.ref_name }}"
          body: "Production-ready NS-LLM artifacts validated across Ubuntu/macOS/Windows. See attached artifacts."

      - name: Upload release assets (ubuntu)
        if: always()
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release-artifacts/ubuntu/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets (macos)
        if: always()
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release-artifacts/macos/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets (windows)
        if: always()
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release-artifacts/windows/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
