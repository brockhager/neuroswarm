name: NS-LLM Native Build

# Make sure the workflow has write access to repo contents so release actions can create releases + upload assets
permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to publish (e.g. v0.2.0). When omitted on manual dispatch the publish_release job will be skipped.'
        required: false
  push:
    paths:
      - 'NS-LLM/**'
    tags:
      - 'v*.*.*'

jobs:
  build:
    runs-on: ${{ matrix.os }}
    # Export the VERSION read in the step below so downstream jobs can consume it
    outputs:
      VERSION: ${{ steps.read_version.outputs.VERSION }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4

      - name: Debug Directory Structure (Recursive)
        run: |
          echo "Workspace: ${{ github.workspace }}"
          ls -R ${{ github.workspace }}

      - name: Read repo VERSION (version-id.txt)
        id: read_version
        shell: pwsh
        run: |
          # Cross-platform read of version-id.txt that works across matrix runners
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          # Set step output for job outputs + export to GITHUB_ENV for in-job usage
          "VERSION=$v" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      # removed duplicate version-read step (we now use `read_version` above)

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1


      - name: Install ONNX Runtime (best-effort)
        run: |
          echo "VERSION=${VERSION} — Attempting to install ONNX Runtime for ${RUNNER_OS} (this step is best-effort; configure ONNXRUNTIME_DIR if required)"
          if [ "${RUNNER_OS}" = "Linux" ]; then
            python -m pip install --upgrade pip
            pip install onnxruntime
          fi
        shell: bash

      - name: Prepare native build directory
        shell: bash
        run: |
          echo "Looking for NS-LLM/native in $(pwd)"
          ls -F
          if [ ! -d "NS-LLM/native" ]; then
            echo "NS-LLM/native not found!"
            ls -R
            exit 1
          fi
          cd NS-LLM/native
          mkdir -p build
          cd build
          echo "build directory ready"

      # (ONNX prepare steps run next on tag pushes — we will configure + build afterwards)

      - name: "Ubuntu: Prepare ONNX runtime + quantized model for native inference"
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -e
          echo "Downloading ONNX Runtime package (prebuilt)"
          ORT_VER="${ONNXRUNTIME_VERSION:-1.15.1}"
          URL="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-linux-x64-${ORT_VER}.tgz"
          mkdir -p /tmp/onnxruntime
          echo "Downloading $URL"
          curl -sL "$URL" -o /tmp/onnxruntime/onnx.tgz || (echo 'Failed to download ORT cli tarball' && exit 0)
          if [ -f /tmp/onnxruntime/onnx.tgz ]; then
            tar -xzf /tmp/onnxruntime/onnx.tgz -C /tmp/onnxruntime || true
            # Set a portable ONNXRUNTIME_DIR under project for CMake
            export ONNXRUNTIME_DIR=${{ github.workspace }}/NS-LLM/native/onnxruntime
            mkdir -p "$ONNXRUNTIME_DIR"
            cp -r /tmp/onnxruntime/* "$ONNXRUNTIME_DIR/" || true
            echo "Exported ONNXRUNTIME_DIR=$ONNXRUNTIME_DIR"
          else
            echo "ONNX runtime tarball missing - will attempt to build prototype only"
          fi

          echo "Installing python deps for model export (may take time)"
          python -m pip install --upgrade pip
          pip install 'optimum<2.0' onnxruntime transformers
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt

          echo "Running model pipeline export (all-MiniLM-L6-v2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force

          echo "Running generative model export (gpt2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/export_generative.py --model gpt2 --out ${{ github.workspace }}/NS-LLM/models/gpt2.onnx --quantize || echo "Warning: Generative model export failed (may be due to torch/optimum compatibility)"

          # Copy models to build directory for tests
          mkdir -p ${{ github.workspace }}/NS-LLM/native/build/models
          cp -r ${{ github.workspace }}/NS-LLM/models/* ${{ github.workspace }}/NS-LLM/native/build/models/

          echo "Re-configure native build to link with ONNX runtime (PROTOTYPE_ONLY=OFF) — VERSION=${VERSION}"
          cd ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR"
          cmake --build . --config Release

      - name: "macOS: Prepare ONNX runtime + quantized model for native inference"
        if: matrix.os == 'macos-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        run: |
          set -e
          ORT_VER="${ONNXRUNTIME_VERSION:-1.15.1}"
          # Try x64 then arm64 packages
          URL_X64="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-osx-x64-${ORT_VER}.tgz"
          URL_ARM="https://github.com/microsoft/onnxruntime/releases/download/v${ORT_VER}/onnxruntime-osx-arm64-${ORT_VER}.tgz"
          mkdir -p /tmp/onnxruntime
          echo "Trying $URL_X64"
          curl -sL "$URL_X64" -o /tmp/onnxruntime/onnx.tgz || true
          if [ ! -f /tmp/onnxruntime/onnx.tgz ]; then
            echo "Trying $URL_ARM"
            curl -sL "$URL_ARM" -o /tmp/onnxruntime/onnx.tgz || true
          fi
          if [ -f /tmp/onnxruntime/onnx.tgz ]; then
            tar -xzf /tmp/onnxruntime/onnx.tgz -C /tmp/onnxruntime || true
            export ONNXRUNTIME_DIR=${{ github.workspace }}/NS-LLM/native/onnxruntime
            mkdir -p "$ONNXRUNTIME_DIR"
            cp -r /tmp/onnxruntime/* "$ONNXRUNTIME_DIR/" || true
            echo "ONNXRUNTIME_DIR=$ONNXRUNTIME_DIR"
          else
            echo "No macOS ONNX runtime package found; will attempt prototype-only build"
          fi

          python -m pip install --upgrade pip
          pip install 'optimum<2.0' onnxruntime transformers || true
          pip install -r ${{ github.workspace }}/NS-LLM/model-pipeline/requirements.txt || true

          python ${{ github.workspace }}/NS-LLM/model-pipeline/download_and_export.py --model sentence-transformers/all-MiniLM-L6-v2 --out ${{ github.workspace }}/NS-LLM/models/all-MiniLM-L6-v2.onnx --quantize --force || true

          echo "Running generative model export (gpt2) -> NS-LLM/models"
          python ${{ github.workspace }}/NS-LLM/model-pipeline/export_generative.py --model gpt2 --out ${{ github.workspace }}/NS-LLM/models/gpt2.onnx --quantize || true

          # Copy models to build directory for tests
          mkdir -p ${{ github.workspace }}/NS-LLM/native/build/models
          cp -r ${{ github.workspace }}/NS-LLM/models/* ${{ github.workspace }}/NS-LLM/native/build/models/ || true

          cd ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR" || true
          cmake --build . --config Release || true

      - name: "macOS: Run native inference smoke tests (if built)"
        if: matrix.os == 'macos-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        run: |
          set -e
          cd NS-LLM
          cd NS-LLM && node test-native-inference.js || echo 'native inference tests failed (or missing)'

      - name: "macOS: Run native generative smoke tests (real)"
        if: matrix.os == 'macos-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        run: |
          set -e
          # Skip test if ONNX runtime isn't present (avoid failing whole matrix)
          if [ -n "$ONNXRUNTIME_DIR" ] || [ -f "${{ github.workspace }}/NS-LLM/native/onnxruntime/lib/libonnxruntime.dylib" ]; then
            cd NS-LLM/native/build
            # Run with real inference (no --stub)
            echo '{"cmd":"generate", "text":"The quick brown fox"}' | ./ns-llm-native | grep "tokens_generated"
          else
            echo "SKIP: ONNX runtime missing; skipping native generative real smoke test on macOS"
          fi

          cd NS-LLM && node test-native-inference.js || echo 'native inference tests failed (or missing)'

      - name: "Ubuntu: Run native generative smoke tests (real)"
        if: matrix.os == 'ubuntu-latest'
        run: |
          set -e
          # Skip if ONNX runtime not available
          if [ -n "$ONNXRUNTIME_DIR" ] || [ -f "${{ github.workspace }}/NS-LLM/native/onnxruntime/lib/libonnxruntime.so" ]; then
            cd NS-LLM/native/build
            # Run with real inference (no --stub)
            echo '{"cmd":"generate", "text":"The quick brown fox"}' | ./ns-llm-native | grep "tokens_generated"
          else
            echo "SKIP: ONNX runtime missing; skipping native generative real smoke test on Ubuntu"
          fi

      - name: Compute checksums and manifest (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          set -e
          ARTDIR=${{ github.workspace }}/NS-LLM/native/build
          OUTDIR=${{ runner.temp }}/ns-llm-artifacts
          mkdir -p "$OUTDIR"
          echo "Computing checksums in $ARTDIR"
          if [ -d "$ARTDIR" ]; then
            (cd "$ARTDIR" && find . -type f -print0 | xargs -0 sha256sum) > "$OUTDIR/checksums.txt" || true
            # Build manifest.json with size & path & sha
            echo '{"files": [' > "$OUTDIR/manifest.json"
            first=1
            while IFS= read -r line; do
              sha=$(echo "$line" | awk '{print $1}')
              path=$(echo "$line" | awk '{$1=""; print substr($0,2)}')
              size=$(stat -c%s "$ARTDIR/$path" 2>/dev/null || stat -f%z "$ARTDIR/$path" 2>/dev/null || echo 0)
              if [ "$first" -eq 1 ]; then first=0; else echo "," >> "$OUTDIR/manifest.json"; fi
              printf '{"path":"%s","sha256":"%s","size":%s}' "$path" "$sha" "$size" >> "$OUTDIR/manifest.json"
            done < "$OUTDIR/checksums.txt"
            echo ']}' >> "$OUTDIR/manifest.json"
          else
            echo 'No artifacts folder to checksum; leaving manifest empty' > "$OUTDIR/manifest.json"
          fi

      - name: Compute checksums and manifest (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $artdir = Join-Path "${{ github.workspace }}" 'NS-LLM\native\build'
          $outdir = Join-Path $env:RUNNER_TEMP 'ns-llm-artifacts'
          New-Item -ItemType Directory -Path $outdir -Force | Out-Null
          if (Test-Path $artdir) {
            Get-ChildItem -Path $artdir -Recurse -File | ForEach-Object { $h = Get-FileHash -Algorithm SHA256 -Path $_.FullName; $rel = $_.FullName.Substring($artdir.Length+1).Replace('\\','/'); "$($h.Hash)  $rel" } | Out-File -FilePath (Join-Path $outdir 'checksums.txt') -Encoding utf8
            $files = Get-ChildItem -Path $artdir -Recurse -File | ForEach-Object { $rel = $_.FullName.Substring($artdir.Length+1).Replace('\\','/'); [PSCustomObject]@{path=$rel; sha256=(Get-FileHash -Algorithm SHA256 -Path $_.FullName).Hash; size=(Get-Item $_.FullName).Length } }
            $manifest = @{ files = $files }
            $manifest | ConvertTo-Json -Depth 4 | Out-File -FilePath (Join-Path $outdir 'manifest.json') -Encoding utf8
          } else {
            '{"files": []}' | Out-File -FilePath (Join-Path $outdir 'manifest.json') -Encoding utf8
          }

      - name: Sign checksums (optional)
        if: matrix.os != 'windows-latest'
        continue-on-error: true
        run: |
          set -e
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "No GPG_PRIVATE_KEY present in secrets — skipping signing"
            exit 0
          fi
          mkdir -p $RUNNER_TEMP/gnupg
          export GNUPGHOME=$RUNNER_TEMP/gnupg
          # Attempt import, but do not fail the whole step/workflow if the import data is invalid.
          if ! printf '%s' "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import; then
            echo "GPG import failed — private key may be missing or invalid; skipping signing"
            exit 0
          fi
          # sign the checksums produced earlier
          ARTDIR=$RUNNER_TEMP/ns-llm-artifacts
          if [ -f "$ARTDIR/checksums.txt" ]; then
            # If signing fails, don't treat it as a fatal error (artifacts and manifest are still uploaded)
            if ! gpg --batch --yes --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" -o "$ARTDIR/checksums.txt.sig" --detach-sign "$ARTDIR/checksums.txt"; then
              echo "Warning: checksums signing failed — skipping signature creation"
            fi
          else
            echo 'No checksums.txt present to sign.'
          fi

      - name: Upload native artifacts and metadata
        uses: actions/upload-artifact@v4
        with:
          name: ns-llm-native-${{ matrix.os }}-v${{ env.VERSION }}
          path: |
            NS-LLM/native/build
            ${{ runner.temp }}/ns-llm-artifacts/checksums.txt
            ${{ runner.temp }}/ns-llm-artifacts/manifest.json
            ${{ runner.temp }}/ns-llm-artifacts/checksums.txt.sig

      - name: "Windows: Prepare ONNX runtime + quantized model for native inference"
        id: set_ort_version
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          # 1) Initialize with a safe default
          $ORT_VER = '1.15.1'

          # 2) Read the environment variable safely
          $EnvVar = $env:ONNXRUNTIME_VERSION

          # 3) Only overwrite if the env var is non-empty and not the problematic string 'True'
          if (-not [string]::IsNullOrEmpty($EnvVar) -and $EnvVar -ne 'True') {
              $ORT_VER = $EnvVar
          }

          Write-Host "Resolved ONNXRUNTIME_VERSION: $ORT_VER"

          # Write outputs the recommended way for GitHub Actions
          "ort_version=$ORT_VER" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          $DownloadBaseName = "v${ORT_VER}"
          "download_prefix=$DownloadBaseName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: "Windows: Validate ONNX Runtime Download URL"
        id: validate_ort_url
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        env:
          ORT_VER: ${{ steps.set_ort_version.outputs.ort_version }}
          DOWNLOAD_PREFIX: ${{ steps.set_ort_version.outputs.download_prefix }}
        run: |
          # Build candidate URLs and test primary -> fallback
          $BaseUrl = 'https://github.com/microsoft/onnxruntime/releases/download/'
          $DownloadPrefix = $env:DOWNLOAD_PREFIX

          # Normalize version for creating filenames (strip leading 'v' if present)
          if ($DownloadPrefix.StartsWith('v')) { $TestVersion = $DownloadPrefix.Substring(1) } else { $TestVersion = $DownloadPrefix }

          $PrimarySuffix = "onnxruntime-win-x64-${TestVersion}.zip"
          $FallbackSuffix = "onnxruntime-win-x64-${TestVersion}.tgz"

          $PrimaryUrl = "$BaseUrl$DownloadPrefix/$PrimarySuffix"
          $FallbackUrl = "$BaseUrl$DownloadPrefix/$FallbackSuffix"

          Write-Host "Attempting primary URL: $PrimaryUrl"

          function Test-UrlExistence {
            param([Parameter(Mandatory=$true)][string]$Url)
            try {
              $response = Invoke-WebRequest -Uri $Url -Method Head -MaximumRedirection 5 -UseBasicParsing -ErrorAction Stop
              if ($response.StatusCode -ge 200 -and $response.StatusCode -lt 400) {
                Write-Host "✅ Success — URL responded with $($response.StatusCode). Package found at: $Url"
                return $true
              } else {
                Write-Host "URL responded with unacceptable status code: $($response.StatusCode)."
                return $false
              }
            } catch {
              Write-Host "URL check failed (likely 404/Connection Error). Error: $($_.Exception.Message)"
              return $false
            }
          }

          $chosen = $null
          if (Test-UrlExistence -Url $PrimaryUrl) {
            $chosen = $PrimaryUrl
            $chosenSuffix = $PrimarySuffix
          } elseif (Test-UrlExistence -Url $FallbackUrl) {
            Write-Host "Note: Primary URL not found; using fallback URL: $FallbackUrl"
            $chosen = $FallbackUrl
            $chosenSuffix = $FallbackSuffix
          } else {
            Write-Host "❌ FATAL ERROR: Neither the primary ($PrimarySuffix) nor the fallback ($FallbackSuffix) ONNX Runtime package was found at the expected release location."
            exit 1
          }

          # Export chosen info to GITHUB_OUTPUT for downstream steps
          "download_url=$chosen" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "download_suffix=$chosenSuffix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: "Windows: Download and extract ONNX Runtime (if URL validated)"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        env:
          ORT_VER: ${{ steps.set_ort_version.outputs.ort_version }}
          DOWNLOAD_PREFIX: ${{ steps.set_ort_version.outputs.download_prefix }}
          DOWNLOAD_URL: ${{ steps.validate_ort_url.outputs.download_url }}
          DOWNLOAD_SUFFIX: ${{ steps.validate_ort_url.outputs.download_suffix }}
        run: |
          $url = $env:DOWNLOAD_URL
          # Pick a temporary filename that matches the chosen suffix so extraction works correctly
          if ($env:DOWNLOAD_SUFFIX -and $env:DOWNLOAD_SUFFIX -match '\.tgz$') { $out = Join-Path $env:TEMP 'onnxruntime.tgz' } else { $out = Join-Path $env:TEMP 'onnxruntime.zip' }

          Write-Host "Downloading $url to $out"
          # Download and extract to a temporary folder first, then normalize layout so lib/ include/ are at the dest root
          Invoke-WebRequest -Uri $url -OutFile $out -UseBasicParsing -ErrorAction Stop

          $tmp = Join-Path $env:TEMP ('onnxruntime_extract_' + [guid]::NewGuid().ToString())
          New-Item -ItemType Directory -Path $tmp -Force | Out-Null

          if ($out -match '\.zip$') {
            Expand-Archive -Path $out -DestinationPath $tmp -Force
          } else {
            # tar extract for tgz
            tar -xzf $out -C $tmp
          }

          # If the archive unpacks into a single top-level directory (eg onnxruntime-win-x64-1.15.1), use its child contents
          $entries = Get-ChildItem -Path $tmp
          $sourceFolder = $tmp
          if ($entries.Count -eq 1 -and $entries[0].PSIsContainer) { $sourceFolder = $entries[0].FullName }

          $dest = Join-Path "${{ github.workspace }}" 'NS-LLM\native\onnxruntime'
          New-Item -ItemType Directory -Path $dest -Force | Out-Null

          # Move contents from sourceFolder into dest (lib, include, tools, etc.). If items already exist remove+replace.
          Get-ChildItem -Path $sourceFolder | ForEach-Object {
            $target = Join-Path $dest $_.Name
            if (Test-Path $target) { Remove-Item -Path $target -Recurse -Force -ErrorAction SilentlyContinue }
            Move-Item -Path $_.FullName -Destination $dest -Force
          }

          # cleanup and set env
          Remove-Item -Path $tmp -Recurse -Force -ErrorAction SilentlyContinue
          $env:ONNXRUNTIME_DIR = $dest
          Write-Host "ONNXRUNTIME_DIR=$env:ONNXRUNTIME_DIR"

          # Install python deps for model export
          python -m pip install --upgrade pip
          pip install 'optimum<2.0' onnxruntime transformers
          pip install -r "${{ github.workspace }}\NS-LLM\model-pipeline\requirements.txt"
          
          # Export embedding model
          python "${{ github.workspace }}\NS-LLM\model-pipeline\download_and_export.py" --model sentence-transformers/all-MiniLM-L6-v2 --out "${{ github.workspace }}\NS-LLM\models\all-MiniLM-L6-v2.onnx" --quantize --force

          # Export generative model
          Write-Host "Running generative model export (gpt2) -> NS-LLM/models"
          python "${{ github.workspace }}\NS-LLM\model-pipeline\export_generative.py" --model gpt2 --out "${{ github.workspace }}\NS-LLM\models\gpt2.onnx" --quantize

          # Copy models to build directory for tests
          $modelsDest = Join-Path "${{ github.workspace }}" 'NS-LLM\native\build\Release\models'
          New-Item -ItemType Directory -Path $modelsDest -Force | Out-Null
          Copy-Item -Path "${{ github.workspace }}\NS-LLM\models\*" -Destination $modelsDest -Recurse -Force

          # Reconfigure CMake with ONNXRUNTIME_DIR for Windows
          Push-Location ${{ github.workspace }}/NS-LLM/native/build
          cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$env:ONNXRUNTIME_DIR" || Write-Host 'cmake configure failed'
          cmake --build . --config Release || Write-Host 'cmake build failed'
          Pop-Location

      - name: "Windows: Smoke Test Extracted ONNX Runtime"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          $LibraryPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "NS-LLM/native/onnxruntime/lib/onnxruntime.lib"
          Write-Host "Verifying existence of core library file: $LibraryPath"
          if (Test-Path $LibraryPath -PathType Leaf) {
              Write-Host "✅ Smoke Test Passed: onnxruntime.lib found! The package was successfully downloaded and extracted."
          } else {
              Write-Host "❌ FATAL ERROR: Smoke Test Failed. Expected library file not found at $LibraryPath."
              Write-Host "This indicates a failure in download, extraction, or an unexpected change in the ONNX Runtime package structure."
              exit 1
          }

      - name: "Windows: Run native inference smoke tests (if built)"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          Set-Location NS-LLM
          node test-native-inference.js || Write-Host 'native inference tests failed (or missing)'

      - name: "Windows: Run native generative smoke tests (real)"
        if: matrix.os == 'windows-latest' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        shell: pwsh
        run: |
          # Skip if ONNX runtime isn't present on Windows
          $lib = Join-Path $env:GITHUB_WORKSPACE 'NS-LLM/native/onnxruntime/lib/onnxruntime.lib'
          if ($env:ONNXRUNTIME_DIR -or (Test-Path $lib -PathType Leaf)) {
            Set-Location NS-LLM/native/build/Release
            # Run with real inference (no --stub)
            echo '{"cmd":"generate", "text":"The quick brown fox"}' | .\ns-llm-native.exe | Select-String "tokens_generated"
          } else {
            Write-Host "SKIP: ONNX runtime missing; skipping native generative real smoke test on Windows"
          }

      - name: Configure + Build native binary (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          set -e
          cd NS-LLM/native/build
          set -e
          # If ONNXRUNTIME_DIR is present OR this is a tag push, build with ONNX support.
          if [ -n "$ONNXRUNTIME_DIR" ] || [[ "$GITHUB_REF" == refs/tags/* ]]; then
            echo "Configuring with ONNX support"
            cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$ONNXRUNTIME_DIR"
          else
            echo "Configuring prototype-only build"
            cmake .. -DPROTOTYPE_ONLY=ON
          fi
          cmake --build . --config Release

      - name: Configure + Build native binary (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Push-Location ${{ github.workspace }}/NS-LLM/native/build
          if ($env:ONNXRUNTIME_DIR -or $env:GITHUB_REF -like 'refs/tags/*') {
            Write-Host 'Configuring with ONNX support'
            cmake .. -DPROTOTYPE_ONLY=OFF -DONNXRUNTIME_DIR="$env:ONNXRUNTIME_DIR"
          } else {
            Write-Host 'Configuring prototype-only build'
            cmake .. -DPROTOTYPE_ONLY=ON
          }
          cmake --build . --config Release
          Pop-Location

      - name: Run native unit smoke tests (if built)
        shell: bash
        run: |
          set -e
          cd NS-LLM && node test-native-inference.js || echo 'native inference tests failed (or missing)'

  integration:
    name: Integration tests (NS-LLM prototype + NS Node) — ${{ matrix.runner-os }}
    runs-on: ${{ matrix.runner-os }}
    needs: build
    strategy:
      matrix:
        runner-os: [ubuntu-latest, macos-latest, windows-latest]
    env:
      STRICT_EMBED_DIM: '1'
      CHECK_EMBED_RANGE: '1'
      STRICT_EMBED_RANGE: '1'
      # Use the version exported by the build job (job output) to fetch artifacts
      BUILD_VERSION: ${{ needs.build.outputs.VERSION }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install NS-LLM prototype deps
        working-directory: NS-LLM
        run: npm install

      - name: Debug NS-LLM Directory (Windows)
        if: matrix.runner-os == 'windows-latest'
        shell: pwsh
        run: |
          Write-Host '--- Debug: NS-LLM Directory After NPM CI ---'
          Get-ChildItem -Path (Join-Path $env:GITHUB_WORKSPACE 'NS-LLM') -Recurse -Depth 2 | Select-Object -First 100 | Format-Table | Write-Host
          Write-Host '------------------------------------------'

      - name: Install Shared deps
        working-directory: shared
        run: npm install

      - name: Install NS Node deps
        working-directory: ns-node
        run: npm ci

      - name: Try to download native binary artifact (for this runner)
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-${{ matrix.runner-os }}-v${{ env.BUILD_VERSION }}
          path: NS-LLM/native/artifact
        continue-on-error: true

      - name: Start NS-LLM backend (Linux/macOS - use Node.js prototype for E2E)
        if: matrix.runner-os != 'windows-latest'
        working-directory: NS-LLM
        run: |
          if [ -f package.json ]; then echo 'Installing NS-LLM dependencies'; npm ci; else echo 'No package.json found; skipping npm ci'; fi
          echo "Starting Node.js prototype for E2E tests"
          nohup node index.js > ns-llm.log 2>&1 &
          NS_LLM_PID=$!
          echo "Started with PID: $NS_LLM_PID"
          sleep 2
          if ps -p $NS_LLM_PID > /dev/null; then
            echo "Process is running"
          else
            echo "Process died! Log:"
            cat ns-llm.log 2>/dev/null || echo "No log"
            exit 1
          fi

      - name: Start NS Node (Linux/macOS)
        if: matrix.runner-os != 'windows-latest'
        working-directory: ns-node
        run: |
          nohup node server.js > ns-node.log 2>&1 &

      - name: Start NS Node (Windows)
        if: matrix.runner-os == 'windows-latest'
        working-directory: ns-node
        shell: pwsh
        run: |
          Start-Process -FilePath node -ArgumentList 'server.js' -NoNewWindow

      - name: Start NS-LLM backend (Windows - fallback to Node prototype)
        if: matrix.runner-os == 'windows-latest'
        working-directory: NS-LLM
        shell: pwsh
        run: |
          Write-Host "Preparing NS-LLM on Windows runner..."
          # Install local deps (safe, index.js is dependency-free but this helps surface missing files during CI)
          if (Test-Path -Path package.json) { Write-Host 'Installing NS-LLM dependencies'; npm ci } else { Write-Host 'No package.json' }

          # If native windows artifact exists under release-artifacts/windows, attempt to start it.
          $nativeDir = Join-Path $PSScriptRoot '..\release-artifacts\windows'
          if (Test-Path $nativeDir) {
            Write-Host "Found native artifacts in $nativeDir - attempting to locate an executable"
            $exe = Get-ChildItem -Path $nativeDir -Recurse -Filter '*.exe' -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($exe) {
                Write-Host "Found native executable: $($exe.FullName) - starting"
                # start native and redirect output to log files inside the repository so CI can access them
                $nativeOut = Join-Path $env:GITHUB_WORKSPACE 'NS-LLM\ns-llm-native.log'
                $nativeErr = Join-Path $env:GITHUB_WORKSPACE 'NS-LLM\ns-llm-native.err.log'
                $proc = Start-Process -FilePath $exe.FullName -NoNewWindow -RedirectStandardOutput $nativeOut -RedirectStandardError $nativeErr -PassThru
                Start-Sleep -Seconds 2
                if (Get-Process -Id $proc.Id -ErrorAction SilentlyContinue) {
                  Write-Host "Started native executable (pid=$($proc.Id)); stdout -> $nativeOut stderr -> $nativeErr"
                  exit 0
                } else {
                  Write-Host "Native executable failed to start, dumping logs (if present):"
                  if (Test-Path $nativeOut) { Write-Host "--- native stdout ---"; Get-Content $nativeOut -ErrorAction SilentlyContinue | Write-Host }
                  if (Test-Path $nativeErr) { Write-Host "--- native stderr ---"; Get-Content $nativeErr -ErrorAction SilentlyContinue | Write-Host }
                  # continue to fallback below
                }
            } else {
              Write-Host 'No native executable found in artifact path; falling back to node prototype'
            }
          } else {
            Write-Host 'No windows artifacts directory present, falling back to node prototype'
          }

          # Fallback: start the prototype Node server so downstream checks can run
          Write-Host 'Starting Node prototype (index.js) on Windows via detached Start-Process'
          $out = Join-Path $env:GITHUB_WORKSPACE 'NS-LLM\ns-llm.log'
          $err = Join-Path $env:GITHUB_WORKSPACE 'NS-LLM\ns-llm.err.log'
          $indexPath = Join-Path $env:GITHUB_WORKSPACE 'NS-LLM\index.js'

          # Use an explicit absolute path to the repository copy of index.js
          # $PSScriptRoot can sometimes be ephemeral in runner temp dirs; use the
          # workspace path to avoid NODE trying to run D:\a\_temp\index.js.
          if (-not (Test-Path $indexPath)) {
            Write-Host "index.js not found at $indexPath — listing NS-LLM folder for debugging"
            Get-ChildItem -Path (Join-Path $env:GITHUB_WORKSPACE 'NS-LLM') -Recurse -Depth 2 | Select-Object -First 50 | Write-Host
            exit 1
          }

          # 1. Start the process detached, redirecting streams to *different* files (to satisfy Start-Process rules)
          $proc = Start-Process -FilePath node -ArgumentList $indexPath -WorkingDirectory (Split-Path $indexPath -Parent) -RedirectStandardOutput $out -RedirectStandardError $err -PassThru
          Start-Sleep -Seconds 2  # Give time for Node to start/crash

          # 2. Append the error log into the main log file to merge the crash trace
          if (Test-Path $err) {
            Write-Host "Merging stderr into main log."
            Get-Content $err | Add-Content $out
          }

          if (Get-Process -Id $proc.Id -ErrorAction SilentlyContinue) {
            Write-Host "Started node prototype (pid=$($proc.Id)); stdout -> $out stderr -> $err (Merged)"
          } else {
            Write-Host "Failed to start node prototype; crash trace should be in $out"
          }

      - name: Wait for services to be healthy (Linux/macOS)
        if: matrix.runner-os != 'windows-latest'
        run: |
          set -e
          NS_LLM_UP=false
          for i in {1..30}; do
            echo "Checking ns-llm at http://127.0.0.1:5555/health... ($i)"
            if curl --silent --fail http://127.0.0.1:5555/health >/dev/null 2>&1; then
              echo "ns-llm is up"
              NS_LLM_UP=true
              break
            fi
            sleep 1
          done
          
          NS_NODE_UP=false
          for i in {1..30}; do
            echo "Checking ns-node at http://127.0.0.1:3009/health... ($i)"
            if curl --silent --fail http://127.0.0.1:3009/health >/dev/null 2>&1; then
              echo "ns-node is up"
              NS_NODE_UP=true
              break
            fi
            sleep 1
          done
          
          # Check if services started successfully
          if [ "$NS_LLM_UP" = false ]; then
            echo "ERROR: ns-llm failed to start. Logs:"
            cat NS-LLM/ns-llm.log 2>/dev/null || cat NS-LLM/ns-llm-native.log 2>/dev/null || echo "No logs found"
            exit 1
          fi
          
          if [ "$NS_NODE_UP" = false ]; then
            echo "ERROR: ns-node failed to start. Logs:"
            cat ns-node/ns-node.log 2>/dev/null || echo "No logs found"
            exit 1
          fi

      - name: Run smoke + e2e tests (prototype/native)
        working-directory: ns-node
        shell: bash
        run: |
          set -e
          npm run test:smoke:ns-llm
          npm run test:e2e:embed

      - name: Run strict embed test (native path validation)
        working-directory: ns-node
        shell: bash
        run: |
          set -e
          echo "Running strict embed check (STRICT_EMBED_DIM=1)"
          STRICT_EMBED_DIM=1 npm run test:e2e:embed

  publish_release:
    name: Publish release artifacts (optional)
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/') }}
    steps:
      - uses: actions/checkout@v4

      - name: Read repo VERSION (version-id.txt) — Linux / macOS
        if: runner.os != 'Windows'
        run: |
          if [ -f "version-id.txt" ]; then
            VERSION=$(cat version-id.txt | tr -d '\n' | tr -d '\r')
          else
            VERSION=dev
          fi
          echo "Read VERSION=$VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Read repo VERSION (version-id.txt) — Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (Test-Path -Path version-id.txt) { $v = (Get-Content version-id.txt -Raw).Trim() } else { $v = 'dev' }
          Write-Host "Read VERSION=$v"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$v"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-ubuntu-latest-v${{ env.VERSION }}
          path: release-artifacts/ubuntu || true

      - name: Download macOS artifact
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-macos-latest-v${{ env.VERSION }}
          path: release-artifacts/macos || true

      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: ns-llm-native-windows-latest-v${{ env.VERSION }}
          path: release-artifacts/windows || true

      - name: Determine release tag
        id: determine_tag
        shell: bash
        run: |
          # Determine a tag for the release. Priority order:
          # 1) workflow_dispatch input 'tag' (if provided)
          # 2) current git ref name if this is a tag push
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.tag }}" ]; then
            echo "RELEASE_TAG=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
          elif [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            # strip refs/tags/
            REF_NAME=${GITHUB_REF#refs/tags/}
            echo "RELEASE_TAG=${REF_NAME}" >> $GITHUB_OUTPUT
          else
            echo "RELEASE_TAG=" >> $GITHUB_OUTPUT
          fi

      - name: Ensure GitHub Release exists (idempotent)
        if: ${{ steps.determine_tag.outputs.RELEASE_TAG != '' }}
        id: ensure_release
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ steps.determine_tag.outputs.RELEASE_TAG }}
        run: |
          set -euo pipefail
          echo "Checking for existing release for tag: $TAG"
          status=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$REPO/releases/tags/$TAG" || true)
          if [ "$status" = "200" ]; then
            echo "Release for $TAG already exists (status $status)"
            # fetch release JSON and extract id so uploads can target a specific release
            id_json=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$REPO/releases/tags/$TAG")
            REL_ID=$(echo "$id_json" | python -c 'import sys, json; o=json.load(sys.stdin); print(o.get("id",""))')
            echo "release_exists=true" >> $GITHUB_OUTPUT
            echo "release_id=${REL_ID}" >> $GITHUB_OUTPUT
          else
            echo "No existing release found for $TAG (status $status) — creating"
            body='{ "tag_name": "'$TAG'", "name": "NS-LLM Phase A artifacts - '$TAG'", "body": "Production-ready NS-LLM artifacts validated across Ubuntu/macOS/Windows. See attached artifacts." }'
            create_status=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" -d "$body" "https://api.github.com/repos/$REPO/releases" || true)
            if [ "$create_status" = "201" ]; then
              echo "Release created successfully (status $create_status)"
              # fetch created release JSON to obtain id
              id_json=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$REPO/releases/tags/$TAG")
              REL_ID=$(echo "$id_json" | python -c 'import sys, json; o=json.load(sys.stdin); print(o.get("id",""))')
              echo "release_created=true" >> $GITHUB_OUTPUT
              echo "release_id=${REL_ID}" >> $GITHUB_OUTPUT
            elif [ "$create_status" = "422" ]; then
              # Another runner created the release concurrently — treat as success and continue
              echo "Create returned 422 (already_exists) — proceeding to reuse existing release"
              # fetch the release id for the existing release
              id_json=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$REPO/releases/tags/$TAG")
              REL_ID=$(echo "$id_json" | python -c 'import sys, json; o=json.load(sys.stdin); print(o.get("id",""))')
              echo "release_exists=true" >> $GITHUB_OUTPUT
              echo "release_id=${REL_ID}" >> $GITHUB_OUTPUT
            else
              echo "Release creation returned unexpected status: $create_status" >&2
              # fail the step so CI surfaces a clear error — but we could choose to continue
              exit 1
            fi
          fi

      - name: Upload release assets (ubuntu)
        if: ${{ steps.determine_tag.outputs.RELEASE_TAG != '' }}
        shell: bash
        env:
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ steps.ensure_release.outputs.release_id }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "$RELEASE_ID" ]; then echo "No release id found" >&2; exit 1; fi
          shopt -s globstar || true
          for f in release-artifacts/ubuntu/**; do
            if [ -f "$f" ]; then
              name=$(basename "$f")
              echo "Uploading $name"
              curl -s -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$f" \
                "https://uploads.github.com/repos/$REPO/releases/$RELEASE_ID/assets?name=$name"
            fi
          done

      - name: Upload release assets (macos)
        if: ${{ steps.determine_tag.outputs.RELEASE_TAG != '' }}
        shell: bash
        env:
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ steps.ensure_release.outputs.release_id }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "$RELEASE_ID" ]; then echo "No release id found" >&2; exit 1; fi
          shopt -s globstar || true
          for f in release-artifacts/macos/**; do
            if [ -f "$f" ]; then
              name=$(basename "$f")
              echo "Uploading $name"
              curl -s -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$f" \
                "https://uploads.github.com/repos/$REPO/releases/$RELEASE_ID/assets?name=$name"
            fi
          done

      - name: Upload release assets (windows)
        if: ${{ steps.determine_tag.outputs.RELEASE_TAG != '' }}
        shell: bash
        env:
          REPO: ${{ github.repository }}
          RELEASE_ID: ${{ steps.ensure_release.outputs.release_id }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "$RELEASE_ID" ]; then echo "No release id found" >&2; exit 1; fi
          shopt -s globstar || true
          for f in release-artifacts/windows/**; do
            if [ -f "$f" ]; then
              name=$(basename "$f")
              echo "Uploading $name"
              curl -s -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$f" \
                "https://uploads.github.com/repos/$REPO/releases/$RELEASE_ID/assets?name=$name"
            fi
          done
