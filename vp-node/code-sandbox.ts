// code-sandbox.ts
// CN-06-A: LLM Worker Code Sandbox Implementation (Simulator)
// This module defines a simulated environment for safely executing code generated by the LLM
// or code provided as context for analysis. This is critical for security and analysis tasks.

import crypto from 'crypto';

// --- MOCK UTILITIES ---

class Logger {
    private serviceName: string;
    constructor(serviceName: string) { this.serviceName = serviceName; }
    public info(message: string, context?: Record<string, any>): void {
        console.log(`[${this.serviceName} - INFO] ${message} ${context ? JSON.stringify(context) : ''}`);
    }
    public warn(message: string, context?: Record<string, any>): void {
        console.warn(`[${this.serviceName} - WARN] ${message} ${context ? JSON.stringify(context) : ''}`);
    }
    public error(message: string, context?: Record<string, any>): void {
        console.error(`[${this.serviceName} - ERROR] ${message} ${context ? JSON.stringify(context) : ''}`);
    }
}
const logger = new Logger('CODE-SANDBOX');

// --- 1. SANDBOX CONFIGURATION ---

const RESOURCE_LIMITS = {
    // Maximum execution time allowed for the code snippet
    timeoutMs: 500, 
    // Simulated maximum memory allocation (in MB)
    maxMemoryMB: 128, 
    // List of forbidden environment variables that the code should not access
    forbiddenEnvKeys: ['AWS_SECRET_KEY', 'DB_PASSWORD', 'JWT_SECRET'],
};

// --- 2. SANDBOX EXECUTION CORE ---

/**
 * Simulates executing arbitrary JavaScript code within a secure, resource-limited sandbox.
 * @param codeSnippet The code string to execute.
 * @param executionId The trace ID for logging.
 * @returns An object containing the output or error details.
 */
export async function executeCodeInSandbox(codeSnippet: string, executionId: string): Promise<{ output: string, metrics: { timeMs: number } }> {
    logger.info('Sandbox execution requested.', { executionId, codeLength: codeSnippet.length });
    const startTime = Date.now();

    // --- SECURITY STEP 1: Environment Isolation Check ---
    
    // Check for attempts to access any forbidden environment variables/keys
    const envScrubbed = RESOURCE_LIMITS.forbiddenEnvKeys.some(key => codeSnippet.includes(key));
    if (envScrubbed) {
        logger.error('Code failed security check: Attempted to access forbidden environment keys.', { executionId });
        throw new Error('Security Violation: Access to restricted resources detected.');
    }
    
    // --- SECURITY STEP 2: Resource Limit Simulation (Timeout) ---
    // Simulating a long-running/blocking task
    if (codeSnippet.includes('while (true)')) {
        logger.warn('Code snippet contains simulated blocking operation. Simulating timeout.', { executionId });
        await new Promise(resolve => setTimeout(resolve, RESOURCE_LIMITS.timeoutMs + 100)); 
        throw new Error(`Execution Timeout: Code exceeded the ${RESOURCE_LIMITS.timeoutMs}ms limit.`);
    }

    try {
        // --- EXECUTION STEP 3: Simulated Execution ---
        
        let simulatedOutput = '';
        
        // Mocking the behavior of logging output
        const mockLog = (msg: any) => { simulatedOutput += String(msg) + '\n'; };
        
        // Simple simulation of execution logic based on common code structures
        if (codeSnippet.includes('2 + 2')) {
            mockLog('Result: 4');
        } else if (codeSnippet.includes('crypto')) {
            mockLog(`Generated ID: ${crypto.randomBytes(4).toString('hex')}`);
        } else {
             mockLog('Code executed successfully with no detectable output.');
        }

        const endTime = Date.now();
        const duration = endTime - startTime;

        if (duration > RESOURCE_LIMITS.timeoutMs && !codeSnippet.includes('while (true)')) {
             throw new Error(`Execution Timeout: Code exceeded the ${RESOURCE_LIMITS.timeoutMs}ms limit.`);
        }
        
        logger.info('Sandbox execution complete.', { executionId, durationMs: duration, outputLength: simulatedOutput.length });
        
        return { 
            output: simulatedOutput.trim(), 
            metrics: { timeMs: duration } 
        };

    } catch (error) {
        logger.error('Code execution error within sandbox.', error, { executionId });
        throw new Error(`Sandbox Execution Failed: ${error instanceof Error ? error.message : String(error)}`);
    }
}


// --- 3. VERIFICATION / TEST SUITE ---

async function runSandboxTests() {
    console.log('\n--- Running Code Sandbox Security & Functionality Tests (CN-06-A) ---');
    
    const testCases = [
        { 
            name: "Success: Simple Math", 
            code: "let x = 2 + 2; console.log('Result: ' + x);", 
            expectedPartial: "Result: 4" 
        },
        { 
            name: "Failure: Timeout (simulated)", 
            code: "let i = 0; while (true) { i++; }", 
            expectedError: "Execution Timeout" 
        },
        { 
            name: "Failure: Environment Access (Security Check)", 
            code: "console.log(process.env.DB_PASSWORD);", 
            expectedError: "Security Violation" 
        },
        { 
            name: "Success: Using External Module Mock (Cryptography)", 
            code: "require('crypto').randomBytes(4);", 
            expectedPartial: "Generated ID:" 
        }
    ];

    let passedCount = 0;
    for (const [index, test] of testCases.entries()) {
        const testId = `TEST-${index + 1}`;
        try {
            const result = await executeCodeInSandbox(test.code, testId);
            if (test.expectedError) {
                // Should have failed, but succeeded
                console.error(`❌ Test Failed (${test.name}): Expected error, but succeeded with output: ${result.output}`);
            } else if (result.output.includes(test.expectedPartial!)) {
                console.log(`✅ Test Passed (${test.name})`);
                passedCount++;
            } else {
                console.error(`❌ Test Failed (${test.name}): Output did not contain expected partial: ${test.expectedPartial}`);
            }
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            if (test.expectedError && errorMessage.includes(test.expectedError)) {
                console.log(`✅ Test Passed (${test.name}): Caught expected error.`);
                passedCount++;
            } else {
                 console.error(`❌ Test Failed (${test.name}): Caught unexpected error: ${errorMessage}`);
            }
        }
    }
    console.log(`\nCN-06-A Verification Summary: ${passedCount}/${testCases.length} tests passed.`);
}

runSandboxTests();
