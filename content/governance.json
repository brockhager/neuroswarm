{
  "title": "NeuroSwarm Governance Design",
  "slug": "governance",
  "content": "<div style=\"max-width: 800px; margin: 0 auto; padding: 0 20px;\"><h1>NeuroSwarm Governance Design</h1><p><strong>Version:</strong> 0.1<br><strong>Date:</strong> 2025-11-11</p><p>This document defines the governance system for the NeuroSwarm Personal AI Economy. It covers staking, voting, consensus flow, auditability, incentives, slashing/penalties, dispute resolution, data schemas, and pseudocode. The design emphasizes democratic participation, transparency, and auditable on-chain records.</p><h2>Table of Contents</h2><ul><li>Goals &amp; Principles</li><li>Roles &amp; Responsibilities</li><li>Staking</li><li>Voting Mechanisms</li><li>Consensus Flow (step-by-step)</li><li>Auditability &amp; On-chain Records</li><li>Incentives, Rewards &amp; Penalties</li><li>Slashing &amp; Dispute Resolution</li><li>Dynamic Validator Sizing</li><li>Weighting: Token, Reputation, Hybrid</li><li>Smart-Contract Primitives &amp; Events</li><li>Data Schemas &amp; Pseudocode</li><li>Security Considerations &amp; Edge Cases</li><li>Example Workflows</li><li>Appendix: Parameter suggestions and implementation checklist</li></ul><hr><h2>Goals &amp; Principles</h2><p><strong>Design goals</strong></p><ul><li>Democratic participation: any user may participate, subject to minimum staking and identity rules.</li><li>Transparency: every governance action and vote is auditable on-chain.</li><li>Fairness: weights combine stake and reputation to balance economic skin and long-run trust.</li><li>Safety: staking acts as collateral; slashing deters dishonest behavior.</li><li>Scalability: validator sets adjust dynamically with network growth.</li></ul><p><strong>Core principles</strong></p><ul><li>Openness: governance rules and parameters are public and upgradable via governance.</li><li>Traceability: each proposal's full history is recorded with CIDs for off-chain artifacts.</li><li>Reversibility: critical actions (e.g., protocol upgrades) have delays and rollback paths.</li></ul><hr><h2>Roles &amp; Responsibilities</h2><ul><li><strong>User:</strong> runs a Personal AI, can submit proposals, vote, and offer optional compute or services.</li><li><strong>Proposer:</strong> a node that submits a governance proposal or knowledge proposal.</li><li><strong>Validator:</strong> a staked and optionally reputation-qualified node assigned to verify proposals and cast votes.</li><li><strong>Aggregator/Coordinator:</strong> off-chain service that collects votes, computes confidence, and triggers finalization (on-chain calls).</li><li><strong>Auditor:</strong> independent or bounty-paid party that replays verification and can open disputes.</li><li><strong>Governance Committee (optional):</strong> reputation-elected group for emergency actions.</li></ul><hr><h2>Staking</h2><p><strong>Purpose</strong></p><p>Staked tokens grant voting power and validator eligibility and act as collateral against dishonest or negligent behavior.</p><p><strong>Staking rules</strong></p><ul><li>Minimum stake S_min required to be eligible as a validator.</li><li>Lockup period L_lock for staked tokens while actively participating (configurable).</li><li>Unstaking delay L_unstake after withdrawal request (gives time to process disputes and slashing).</li></ul><p><strong>Staking actions</strong></p><ul><li><code>stake(amount):</code> increase stake balance and on-chain voting weight</li><li><code>withdraw(amount):</code> mark withdrawal; funds returned after L_unstake unless slashed</li></ul><p><strong>Staking rewards</strong></p><ul><li>Yield on stake: small baseline yield (e.g., protocol-defined fraction) paid from epoch reward pool</li><li>Governance bonuses: additional rewards for active voting participation and correct attestations</li></ul><p><strong>Collateral &amp; slashing</strong></p><ul><li>A portion of stake can be slashed for proven malicious behavior (forgery, collusion, false attestations)</li><li>Slashing parameters: fraction or fixed amount; configurable by governance</li></ul><p><strong>Example parameters (suggestion)</strong></p><ul><li>S_min = 10 tokens</li><li>L_lock = active participation window (e.g., stake locked for active sets)</li><li>L_unstake = 7 days</li><li>Slashing fraction = variable; e.g., 1–100% depending on severity</li></ul><hr><h2>Voting Mechanisms</h2><p><strong>Types of votable items</strong></p><ul><li>Knowledge proposals: add / modify / remove facts (Global Brain)</li><li>Protocol parameters: thresholds, reward splits, validator sizing</li><li>Dataset inclusion / benchmark selection</li><li>Protocol upgrades and migrations</li></ul><p><strong>Voting modes</strong></p><ul><li>Per-proposal validator voting (committee-based) for knowledge proposals and verifications</li><li>Wide DAO-style votes (token-weighted) for high-level economic and protocol parameters</li><li>Reputation-weighted or hybrid voting for technical proposals (to favor informed actors)</li></ul><p><strong>Vote options</strong></p><ul><li>Knowledge proposals: {accept, reject, abstain}</li><li>Parameter proposals: {yes, no, abstain}</li><li>Emergency: fast-track with committee approval + later community ratification</li></ul><p><strong>Voting windows</strong></p><ul><li>Standard voting window (e.g., 7 days) for DAO proposals</li><li>Shorter windows for per-proposal verification (epoch-based) with dispute window after finalization</li></ul><p><strong>Vote weighting</strong></p><ul><li>Token-weighted: weight proportional to staked tokens (optionally saturating)</li><li>Reputation-weighted: weight proportional to reputation score</li><li>Hybrid: weight = alpha * stake_weight + (1 - alpha) * reputation_weight</li><li>Default alpha recommended = 0.6 (subject to governance)</li></ul><p><strong>Abstain handling</strong></p><ul><li>Abstain reduces quorum but must be accounted for in quorum calculations</li></ul><p><strong>Quorum &amp; thresholds</strong></p><ul><li>Quorum q: minimum participation fraction required for a vote to be valid (e.g., 20% of active stake)</li><li>Threshold T: minimum weighted support required for acceptance (e.g., 50% for DAOs, 90% for knowledge inclusion)</li></ul><hr><h2>Consensus Flow (step-by-step)</h2><p>This flow applies to knowledge proposals and per-proposal verification.</p><ol><li><strong>Proposal submission</strong><br>Proposer packages artifact and posts a <code>submitProposal</code> transaction that includes: proposal_id, artifact_cid, proposal_type, stake (optional), and metadata.<br>The on-chain event is emitted: ProposalSubmitted(...)</li><li><strong>Validator set selection</strong><br>System selects a validator committee for this proposal using dynamic sizing (see \"Dynamic Validator Sizing\"). Selection uses pseudo-random sampling weighted by stake and reputation.</li><li><strong>Validator verification &amp; voting</strong><br>Each assigned validator fetches artifact_cid, reconstructs env (env_cid), runs deterministic checks and benchmark, and posts <code>postVote(proposal_id, verdict, metrics_hash, signature)</code> on-chain (or batched merkle root).</li><li><strong>Confidence calculation</strong><br>Aggregator collects votes and computes weighted confidence C = sum(w_v * vote_v) / sum(w_v)<br>Vote_v = 1 for accept, 0 for reject; w_v = weight from stake/reputation formula</li><li><strong>Threshold check</strong><br>If C >= T_inclusion (default 0.90), proposal is accepted and <code>ProposalFinalized</code> is emitted with confidence and manifest CID.<br>If C < T_inclusion but above an escalate threshold, proposal may be queued or sent to bigger committee; if clearly below, it is rejected.</li><li><strong>Blockchain recording</strong><br>All votes, final confidence, and outcome are logged on-chain (or via merkle-batched attestations anchored on-chain).</li><li><strong>Rewards &amp; reputation updates</strong><br>Rewards distributed to proposer and validators according to reward formula; reputation updated (increase for correct votes aligning with final outcome, decrease for misaligned or malicious behavior).</li><li><strong>Dispute window</strong><br>A challenge window (e.g., 48–72 hours) allows disputes. If a dispute is filed, finalization may be paused and expanded verification occurs.</li></ol><p><strong>Reversible points</strong></p><p>Proposal can be withdrawn before finalization (if proposer opts) or challenged after finalization according to dispute rules. Slashing and reward reversals are possible if fraud is proven.</p><hr><h2>Auditability &amp; On-chain Records</h2><p>Every governance action is recorded or anchored on-chain. Key on-chain records:</p><ul><li><code>ProposalSubmitted(proposal_id, proposer, artifact_cid, meta_hash, stake)</code></li><li><code>ValidatorAssigned(proposal_id, validator_ids[], committee_seed)</code></li><li><code>VoteSubmitted(proposal_id, validator, verdict, metrics_hash)</code></li><li><code>ProposalFinalized(proposal_id, entry_id, confidence, manifest_cid)</code></li><li><code>RewardDistributed(epoch, details_cid)</code></li><li><code>DisputeOpened(dispute_id, proposer, evidence_cid)</code></li><li><code>DisputeResolved(dispute_id, outcome, slashed_accounts[])</code></li></ul><p><strong>Off-chain artifacts (content-addressed)</strong></p><ul><li><code>artifact_cid:</code> proposal bundle (artifact, env_manifest, deterministic seeds, proofs)</li><li>metrics files, attestation details (if not on-chain), and audit manifests</li></ul><p><strong>Indexing &amp; explorers</strong></p><ul><li>Off-chain indexer maintains copies of events for fast queries (UI/dashboard) while canonical truth is on-chain.</li><li>Auditor CLI uses on-chain IDs + CIDs to re-run verifications.</li></ul><p><strong>Privacy note</strong></p><p>On-chain stores metadata and hashes only; raw user data is never stored on-chain unless explicitly consented.</p><hr><h2>Incentives, Rewards &amp; Penalties</h2><p><strong>Reward categories</strong></p><ul><li>Participation reward: base reward R_base for casting a vote on an assigned proposal</li><li>Alignment bonus: extra reward for votes aligning with final consensus</li><li>Proposer reward: reward to proposer scaled by final confidence C and measured utility</li><li>Reviewer/Auditor bounty: paid for successful dispute findings or deep audits</li></ul><p><strong>Reward calculation (simplified)</strong></p><pre><code># Epoch pool R_epoch\nfor each accepted proposal p:\n  proposer_reward = R_epoch * alpha * utility_p * C_p\n  validator_base_total = R_epoch * beta  # split across validators\n  for validator v in committee:\n    v_reward = (validator_base_total / N) + (v.vote == final_vote ? bonus_align : 0)</code></pre><ul><li>Parameters alpha, beta set by governance; utility_p derived from deterministic benchmarks and user signals</li></ul><p><strong>Reputation effects</strong></p><ul><li>Reputation increases for accepted proposers and validators whose votes align with consensus; decreases for slashed or repeat-misaligned actors</li><li>Reputation influences future selection probability and vote weight</li></ul><p><strong>Penalties &amp; slashing</strong></p><ul><li>Types of offenses: forged attestations, collusion, deliberate misreporting, repeated incorrect attestations indicating negligence</li><li>Penalty actions: reputation reduction, partial stake slashing, removal from validator eligibility</li><li>Slashing process: requires evidence (on-chain) and adjudication; slashing events are recorded on-chain</li></ul><p><strong>Anti-capture measures</strong></p><ul><li>Cap effective voting weight from a single staked address via saturating functions (e.g., log(1+stake))</li><li>Reputation-based checks to prevent purely token-based oligarchy</li></ul><hr><h2>Slashing &amp; Dispute Resolution</h2><p><strong>Slashing process</strong></p><ol><li>Evidence submission: any party can submit evidence of misbehavior with bond to discourage frivolous claims</li><li>Adjudication: committee or on-chain dispute module evaluates evidence (may run extra verification)</li><li>Ruling &amp; enforcement: if malicious behavior proven, slash stake and adjust reputation; if claim is frivolous, the submitter's bond is burned</li></ol><p><strong>Dispute lifecycle</strong></p><ul><li><code>OpenDispute(proposal_id, evidence_cid, bond)</code></li><li>Assign adjudication committee (larger, reputation-weighted)</li><li>Committee issues ruling: upheld, rejected, or escalate to referendum</li><li>All steps recorded on-chain</li></ul><p><strong>Safeguards</strong></p><ul><li>Multi-stage appeals (committee → larger committee → full referendum) for serious cases</li><li>Time-bound windows and transparency for fairness</li></ul><hr><h2>Dynamic Validator Sizing</h2><p><strong>Motivation</strong></p><p>Larger validator committees increase security but cost more verification work. We scale N dynamically with network size and submission load.</p><p><strong>Heuristic algorithm (example)</strong></p><pre><code># parameters: N_min, N_max, k\nN = clamp(N_min + floor(k * log(total_active_nodes + submissions_last_epoch + 1)), N_min, N_max)</code></pre><ul><li>Alternative: target security level by increasing N when risk metrics (variance in votes, number of disputes) exceed thresholds</li></ul><p><strong>Assignment</strong></p><ul><li>Selected by weighted-random sampling where weight = 1 + gamma * log(1 + reputation) + stake_factor</li><li>Use deterministic committee seed derived from block / epoch to prevent manipulation</li></ul><hr><h2>Weighting: Token, Reputation, or Hybrid</h2><p><strong>Weighting functions</strong></p><ul><li><code>stake_weight(s) = log(1 + s)</code>  # saturating to limit whales</li><li><code>rep_weight(r) = 1 + gamma * log(1 + r)</code></li><li><code>hybrid_weight = alpha * normalize(stake_weight) + (1 - alpha) * normalize(rep_weight)</code></li></ul><p><strong>Recommended defaults</strong></p><ul><li>alpha = 0.6 (slightly favor stake), gamma = 0.5</li><li>Normalize across committee when computing vote weights</li></ul><p><strong>Rationale</strong></p><p>Token stake ensures economic skin; reputation ensures long-term trust and technical knowledge. Hybrid reduces risk of purely bought influence and rewards sustained honest participation.</p><hr><h2>Smart-Contract Primitives &amp; Events</h2><p><strong>Core primitives (conceptual)</strong></p><ul><li><code>submitProposal(proposal_id, artifact_cid, meta_hash, stake)</code></li><li><code>assignValidators(proposal_id, validators[])</code>  // emitted event or on-chain mapping</li><li><code>postVote(proposal_id, verdict, metrics_hash)</code>  // sig verifies validator</li><li><code>finalizeProposal(proposal_id, manifest_cid, confidence)</code></li><li><code>distributeRewards(epoch)</code></li><li><code>stake(amount), requestUnstake(amount)</code></li><li><code>openDispute(proposal_id, evidence_cid, bond)</code></li><li><code>adjudicateDispute(dispute_id, ruling)</code></li></ul><p><strong>Key events</strong></p><ul><li>ProposalSubmitted</li><li>ValidatorAssigned</li><li>VoteSubmitted</li><li>ProposalFinalized</li><li>RewardDistributed</li><li>DisputeOpened</li><li>DisputeResolved</li><li>StakeChanged</li></ul><p><strong>Gas &amp; batching recommendations</strong></p><ul><li>Batch votes via merkle roots to save gas; store merkle root on-chain and proofs/attestations off-chain</li><li>Use L2s / rollups for high-volume activity</li></ul><hr><h2>Data Schemas &amp; Pseudocode</h2><p><strong>ProposalSubmitted event schema (JSON)</strong></p><pre><code>{\n  \"proposal_id\": \"string\",\n  \"proposer\": \"did:...\",\n  \"artifact_cid\": \"Qm...\",\n  \"proposal_type\": \"knowledge|parameter|upgrade\",\n  \"stake\": 10,\n  \"timestamp\": 1699710000\n}</code></pre><p><strong>VoteSubmitted (on-chain / batched) schema</strong></p><pre><code>{\n  \"proposal_id\":\"string\",\n  \"validator\":\"did:...\",\n  \"verdict\":\"accept|reject|abstain\",\n  \"metrics_hash\":\"sha256...\",\n  \"signature\":\"0x...\"\n}</code></pre><p><strong>Confidence calculation (pseudocode)</strong></p><pre><code># inputs: votes = [(validator, verdict, rep, stake), ...]\nweights = [hybrid_weight(rep, stake) for each validator]\nnumer = sum(weight_i * (verdict_i == 'accept' ? 1 : 0))\ndenom = sum(weights)\nraw_conf = numer / denom\nmetric_score = normalize(mean(observed_metric_i))\ncalib = sigmoid(k*(metric_score - expected_metric(proposer_conf)))\nC = clamp(raw_conf * (1 + lambda * calib), 0, 1)</code></pre><p><strong>Reward distribution (pseudocode)</strong></p><pre><code># R_epoch allocated\nfor proposal in accepted_proposals:\n  proposer_pay = R_epoch * alpha * utility(proposal) * C\n  validator_base = (R_epoch * beta) / N\n  for v in validators:\n    pay(v) = validator_base + (v.vote == final ? bonus_align : 0)\n  pay_to_proposer(proposer, proposer_pay)\n  pay_to_validators(validators, pay)</code></pre><p><strong>Validator selection (pseudocode)</strong></p><pre><code># inputs: validator_pool list of (id, rep, stake)\nweights = [1 + gamma*log(1+rep) + stake_factor(stake) for each]\ncommittee = weighted_random_sample(validator_pool, weights, N)\npublish ValidatorAssigned(proposal_id, committee, seed)</code></pre><hr><h2>Security Considerations &amp; Edge Cases</h2><p><strong>Collusion &amp; bribery</strong></p><p>Risk: validators collude for bribers. Mitigations: randomized committees, reputation tracking, slashing, high bond cost for disputes.</p><p><strong>Censorship</strong></p><p>Risk: large staked actors censor proposals. Mitigations: saturating stake weight, reputation-based checks, appeals and larger committees.</p><p><strong>Flash staking attacks</strong></p><p>Risk: attacker farms stake temporarily to influence a vote. Mitigations: minimum lock-up periods, reputation influence, and sliding stake weight windows.</p><p><strong>False evidence &amp; spam</strong></p><p>Bonded dispute submissions to deter frivolous disputes; auditor bounties to encourage evidence submission for real issues.</p><p><strong>Reorgs and finality</strong></p><p>Avoid starting verification until a chain finality threshold is met (or use fast-finality L2).</p><hr><h2>Example Workflows</h2><p><strong>A. Knowledge inclusion (compact)</strong></p><ol><li>Alice submits proposal P with artifact_cid.</li><li>System selects N validators using dynamic sizing.</li><li>Validators fetch artifact, run checks, post votes.</li><li>Aggregator computes C; if C >= 0.9, finalize and publish entry.</li><li>Distribute rewards; update reputation. All steps anchored on-chain.</li></ol><p><strong>B. Dispute &amp; slashing</strong></p><ol><li>Bob files dispute with evidence and bond.</li><li>Committee examines evidence; runs additional verification.</li><li>If Bob right, revert inclusion, slash malicious validators, reward Bob; else burn Bob's bond.</li></ol><hr><h2>Appendix: Parameter Suggestions &amp; Implementation Checklist</h2><p><strong>Suggested starting parameters (tunable by governance)</strong></p><ul><li>Inclusion threshold T_inclusion = 0.90</li><li>Removal threshold T_removal = 0.95</li><li>Minimum stake S_min = 10 tokens</li><li>Unstake delay = 7 days</li><li>Voting window (DAO) = 7 days</li><li>Challenge window (post-finalization) = 48–72 hours</li><li>alpha (stake vs rep) = 0.6</li><li>gamma (rep sensitivity) = 0.5</li><li>N_min = 3, N_max = 51, k = 2</li></ul><p><strong>Implementation checklist</strong></p><ul><li>Smart contracts: staking, proposal lifecycle, voting registry, rewards, disputes</li><li>Indexer: off-chain DB for dashboards and auditors</li><li>Validator runner: deterministic execution environment reference and runner code</li><li>Auditor CLI: fetch on-chain events + CIDs and replay verification</li><li>UI: proposal pages, vote pages, audit explorer, stake management</li></ul></div>",
  "status": "publish",
  "format": "html",
  "metadata": {
    "category": "governance",
    "author": "NeuroSwarm Team",
    "last_updated": "2025-11-11",
    "tags": ["governance", "staking", "voting", "consensus", "blockchain"]
  }
}